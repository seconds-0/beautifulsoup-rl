from __future__ import annotations

"""Base generator infrastructure for BeautifulSoup RL environment.

This module provides the foundational classes and utilities for task generation:
- TaskInstance: The data structure representing a single task
- Generator: The protocol that all archetype generators must follow
- RNG utilities: Deterministic random number generation
- HTML noise helpers: Functions to add realistic noise to HTML
- HtmlStyle: Framework-specific HTML generation patterns
"""

import hashlib
import random
import re
import string
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Sequence


# =============================================================================
# HTML Style System - Framework-Specific Patterns
# =============================================================================


class HtmlStyle(Enum):
    """HTML generation styles matching real-world frameworks.

    Each style produces HTML with characteristic patterns that train models
    to handle the diversity of real-world websites.
    """

    TRADITIONAL = "traditional"  # Wikipedia, docs sites, semantic HTML
    BOOTSTRAP = "bootstrap"  # Bootstrap 4/5 grid, component classes
    TAILWIND = "tailwind"  # Utility-class explosion
    REACT_SPA = "react_spa"  # data-reactroot, hashed classes, hydration
    ANGULAR = "angular"  # ng-* attributes, _ngcontent-* scopes
    VUE = "vue"  # data-v-* attributes, v-* directives


@dataclass
class TaskInstance:
    """A single task instance generated by an archetype generator.

    Attributes:
        html: The HTML content to be parsed.
        query: Natural language description of what to extract.
        ground_truth: The expected correct answer (hidden from model).
        archetype_id: The archetype that generated this instance.
        seed: The seed used to generate this instance.
        solvable: Whether this task is solvable with BS4.
        answer_schema: JSON schema for the expected answer format.
        normalization: Rules for normalizing the answer before comparison.
        limit_info: For limitation tasks, the valid reasons and evidence patterns.
        safety_info: Forbidden patterns and fields to check for safety violations.
        metadata: Additional metadata for analysis and debugging.
    """

    html: str
    query: str
    ground_truth: Any
    archetype_id: str
    seed: int
    solvable: bool = True
    answer_schema: dict = field(default_factory=dict)
    normalization: dict = field(default_factory=lambda: {
        "strip_whitespace": True,
        "collapse_whitespace": True,
        "unicode_nfc": True,
        "sort_lists": False,
        "sort_dict_keys": True,
    })
    limit_info: dict = field(default_factory=lambda: {
        "allowed_reasons": [],
        "evidence_patterns": [],
    })
    safety_info: dict = field(default_factory=lambda: {
        "forbidden_patterns": [],
        "forbidden_fields": [],
    })
    metadata: dict = field(default_factory=dict)

    def to_info_dict(self) -> dict[str, Any]:
        """Convert to the info dict format used in dataset rows.

        Returns:
            Dictionary with all task information for grading.
        """
        return {
            "archetype_id": self.archetype_id,
            "seed": self.seed,
            "solvable": self.solvable,
            "ground_truth": self.ground_truth,
            "answer_schema": self.answer_schema,
            "normalization": self.normalization,
            "limit_info": self.limit_info,
            "safety_info": self.safety_info,
            "metadata": self.metadata,
        }


class Generator(ABC):
    """Abstract base class for task generators.

    Each archetype implements this protocol to generate task instances.
    Generators must be deterministic: same seed -> same output.
    """

    # Set by @register decorator
    _archetype_spec: Any = None

    @property
    def archetype_id(self) -> str:
        """Get the archetype ID from the registered spec."""
        if self._archetype_spec is None:
            raise RuntimeError(
                f"{self.__class__.__name__} was not registered with @register"
            )
        return self._archetype_spec.archetype_id

    @abstractmethod
    def generate(self, seed: int) -> TaskInstance:
        """Generate a task instance from a seed.

        This method must be deterministic: the same seed must always
        produce the same task instance.

        Args:
            seed: Integer seed for reproducible generation.

        Returns:
            A TaskInstance with all required fields populated.
        """
        pass


def stable_int_seed(split: str, archetype_id: str, seed: int) -> int:
    """Generate a stable integer seed from split, archetype, and seed.

    Uses SHA-256 to combine inputs into a deterministic integer.
    This avoids Python's salted hash() which is not reproducible across runs.

    Args:
        split: The dataset split (train, eval, bench).
        archetype_id: The archetype identifier.
        seed: The base seed value.

    Returns:
        A stable integer seed suitable for random.Random().
    """
    data = f"{split}:{archetype_id}:{seed}".encode("utf-8")
    hash_bytes = hashlib.sha256(data).digest()
    # Use first 8 bytes as a 64-bit integer
    return int.from_bytes(hash_bytes[:8], byteorder="big")


def make_rng(archetype_id: str, seed: int, split: str = "train") -> random.Random:
    """Create a seeded random.Random instance for a task.

    Args:
        archetype_id: The archetype identifier.
        seed: The base seed value.
        split: The dataset split (default "train").

    Returns:
        A seeded random.Random instance.
    """
    stable_seed = stable_int_seed(split, archetype_id, seed)
    return random.Random(stable_seed)


# =============================================================================
# HTML Noise and Variation Helpers
# =============================================================================


def random_whitespace(rng: random.Random, min_len: int = 1, max_len: int = 3) -> str:
    """Generate random whitespace string.

    Args:
        rng: Random instance.
        min_len: Minimum length.
        max_len: Maximum length.

    Returns:
        String of random whitespace characters.
    """
    length = rng.randint(min_len, max_len)
    chars = [" ", "\t", "\n"]
    weights = [0.7, 0.2, 0.1]
    return "".join(rng.choices(chars, weights=weights, k=length))


def add_noise_comments(html: str, rng: random.Random, count: int = 3) -> str:
    """Add random HTML comments to the document.

    Args:
        html: The HTML string.
        rng: Random instance.
        count: Number of comments to add.

    Returns:
        HTML with added comments.
    """
    comments = [
        "<!-- TODO: fix this -->",
        "<!-- legacy code -->",
        "<!-- generated by cms -->",
        "<!-- analytics tag -->",
        "<!-- do not modify -->",
        "<!-- end section -->",
        "<!-- begin content -->",
        "<!-- version 2.1 -->",
    ]

    for _ in range(count):
        comment = rng.choice(comments)
        # Find a random position to insert (after a tag close)
        positions = [m.end() for m in re.finditer(r">", html)]
        if positions:
            pos = rng.choice(positions)
            html = html[:pos] + comment + html[pos:]

    return html


def randomize_attribute_order(tag: str, rng: random.Random) -> str:
    """Randomize the order of attributes in an HTML tag.

    Args:
        tag: An HTML tag string like '<div class="foo" id="bar">'.
        rng: Random instance.

    Returns:
        The tag with attributes in random order.
    """
    # Parse the tag
    match = re.match(r"<(\w+)((?:\s+[^>]*)?)\s*/?>", tag)
    if not match:
        return tag

    tag_name = match.group(1)
    attrs_str = match.group(2).strip()

    if not attrs_str:
        return tag

    # Extract attributes
    attr_pattern = r'(\w+)(?:=(?:"([^"]*)"|\'([^\']*)\'|(\S+)))?'
    attrs = re.findall(attr_pattern, attrs_str)

    if len(attrs) <= 1:
        return tag

    # Shuffle attributes
    rng.shuffle(attrs)

    # Reconstruct
    attr_strs = []
    for name, val_dq, val_sq, val_bare in attrs:
        if val_dq:
            attr_strs.append(f'{name}="{val_dq}"')
        elif val_sq:
            attr_strs.append(f"{name}='{val_sq}'")
        elif val_bare:
            attr_strs.append(f"{name}={val_bare}")
        else:
            attr_strs.append(name)

    is_self_closing = tag.rstrip().endswith("/>")
    closing = "/>" if is_self_closing else ">"
    return f"<{tag_name} {' '.join(attr_strs)}{closing}"


def add_decoy_elements(
    html: str,
    rng: random.Random,
    decoys: Sequence[str] | None = None,
    count: int = 2,
) -> str:
    """Add decoy elements that might distract naive extractors.

    Args:
        html: The HTML string.
        rng: Random instance.
        decoys: List of decoy HTML snippets. If None, uses defaults.
        count: Number of decoys to add.

    Returns:
        HTML with added decoy elements.
    """
    if decoys is None:
        decoys = [
            '<div class="hidden" style="display:none">decoy content</div>',
            '<span class="sr-only">screen reader only</span>',
            '<noscript>Enable JavaScript</noscript>',
            '<template id="tmpl">template content</template>',
            '<!-- <div class="old">deprecated</div> -->',
        ]

    for _ in range(count):
        decoy = rng.choice(decoys)
        # Insert before </body> if present, otherwise at end
        if "</body>" in html:
            html = html.replace("</body>", f"{decoy}</body>", 1)
        else:
            html += decoy

    return html


def random_class_name(rng: random.Random, prefix: str = "") -> str:
    """Generate a random CSS class name.

    Args:
        rng: Random instance.
        prefix: Optional prefix for the class name.

    Returns:
        A random class name string.
    """
    suffixes = ["container", "wrapper", "content", "item", "box", "section", "main"]
    modifiers = ["primary", "secondary", "active", "hidden", "new", "old", "v2"]

    parts = [prefix] if prefix else []
    parts.append(rng.choice(suffixes))
    if rng.random() < 0.5:
        parts.append(rng.choice(modifiers))
    if rng.random() < 0.3:
        parts.append(str(rng.randint(1, 99)))

    return "-".join(parts)


def random_id(rng: random.Random, prefix: str = "") -> str:
    """Generate a random HTML ID.

    Args:
        rng: Random instance.
        prefix: Optional prefix for the ID.

    Returns:
        A random ID string.
    """
    base = prefix or rng.choice(["el", "node", "item", "block", "comp"])
    suffix = "".join(rng.choices(string.ascii_lowercase + string.digits, k=6))
    return f"{base}-{suffix}"


def introduce_malformation(
    html: str,
    rng: random.Random,
    malformation_type: str | None = None,
) -> str:
    """Introduce a specific type of HTML malformation.

    Args:
        html: The HTML string.
        rng: Random instance.
        malformation_type: Type of malformation. If None, chooses randomly.
            Options: "unclosed_tag", "missing_quotes", "bad_nesting"

    Returns:
        Malformed HTML string.
    """
    if malformation_type is None:
        malformation_type = rng.choice(["unclosed_tag", "missing_quotes", "bad_nesting"])

    if malformation_type == "unclosed_tag":
        # Remove a closing tag
        closing_tags = list(re.finditer(r"</(\w+)>", html))
        if closing_tags:
            match = rng.choice(closing_tags)
            html = html[: match.start()] + html[match.end() :]

    elif malformation_type == "missing_quotes":
        # Remove quotes from an attribute value (if value has no spaces)
        attr_pattern = r'(\w+)="([^"\s]+)"'
        matches = list(re.finditer(attr_pattern, html))
        if matches:
            match = rng.choice(matches)
            replacement = f"{match.group(1)}={match.group(2)}"
            html = html[: match.start()] + replacement + html[match.end() :]

    elif malformation_type == "bad_nesting":
        # Create overlapping tags (e.g., <b><i>text</b></i>)
        # This is tricky to do safely, so we just add a known bad pattern
        bad_patterns = [
            "<b><i>overlapped</b></i>",
            "<p><div>block in inline</div></p>",
        ]
        pattern = rng.choice(bad_patterns)
        if "</body>" in html:
            html = html.replace("</body>", f"{pattern}</body>", 1)
        else:
            html += pattern

    return html


# =============================================================================
# Content Generation Helpers
# =============================================================================


def random_person_name(rng: random.Random) -> str:
    """Generate a random person name."""
    first_names = [
        "Alice", "Bob", "Carol", "David", "Emma", "Frank", "Grace", "Henry",
        "Ivy", "Jack", "Karen", "Leo", "Maria", "Nathan", "Olivia", "Peter",
    ]
    last_names = [
        "Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia", "Miller",
        "Davis", "Martinez", "Anderson", "Wilson", "Taylor", "Thomas", "Lee",
    ]
    return f"{rng.choice(first_names)} {rng.choice(last_names)}"


def random_company_name(rng: random.Random) -> str:
    """Generate a random company name."""
    prefixes = ["Acme", "Global", "Tech", "Prime", "Alpha", "Omega", "Nova", "Apex"]
    suffixes = ["Corp", "Inc", "LLC", "Solutions", "Systems", "Industries", "Labs"]
    return f"{rng.choice(prefixes)} {rng.choice(suffixes)}"


def random_product_name(rng: random.Random) -> str:
    """Generate a random product name."""
    adjectives = ["Super", "Ultra", "Pro", "Max", "Plus", "Elite", "Premium"]
    nouns = ["Widget", "Gadget", "Tool", "Device", "System", "Kit", "Set"]
    return f"{rng.choice(adjectives)} {rng.choice(nouns)}"


def random_price(rng: random.Random, min_val: float = 9.99, max_val: float = 999.99) -> str:
    """Generate a random price string."""
    value = rng.uniform(min_val, max_val)
    return f"${value:.2f}"


def random_date(rng: random.Random) -> str:
    """Generate a random date string in various formats."""
    year = rng.randint(2020, 2025)
    month = rng.randint(1, 12)
    day = rng.randint(1, 28)  # Safe for all months

    formats = [
        f"{year}-{month:02d}-{day:02d}",
        f"{month:02d}/{day:02d}/{year}",
        f"{day:02d}.{month:02d}.{year}",
    ]
    return rng.choice(formats)


def random_url(rng: random.Random, base: str = "https://example.com") -> str:
    """Generate a random URL."""
    paths = ["products", "about", "contact", "blog", "news", "help", "faq"]
    slugs = ["item", "page", "post", "article", "entry"]
    return f"{base}/{rng.choice(paths)}/{rng.choice(slugs)}-{rng.randint(1, 999)}"


def random_email(rng: random.Random) -> str:
    """Generate a random email address."""
    names = ["user", "contact", "info", "hello", "support", "admin"]
    domains = ["example.com", "test.org", "sample.net", "demo.io"]
    return f"{rng.choice(names)}{rng.randint(1, 999)}@{rng.choice(domains)}"


def random_paragraph(rng: random.Random, sentences: int = 3) -> str:
    """Generate a random paragraph of lorem ipsum-like text."""
    sentence_templates = [
        "The {adj} {noun} {verb} the {noun2}.",
        "A {noun} was {verb} by the {adj} {noun2}.",
        "Several {adj} {noun}s {verb} near the {noun2}.",
        "The {noun} appeared to be {adj} and {verb}.",
    ]
    adjectives = ["quick", "lazy", "bright", "dark", "small", "large", "old", "new"]
    nouns = ["fox", "dog", "cat", "bird", "tree", "house", "car", "book"]
    verbs = ["jumped", "ran", "walked", "flew", "sat", "stood", "moved", "rested"]

    result = []
    for _ in range(sentences):
        template = rng.choice(sentence_templates)
        sentence = template.format(
            adj=rng.choice(adjectives),
            noun=rng.choice(nouns),
            noun2=rng.choice(nouns),
            verb=rng.choice(verbs),
        )
        result.append(sentence)

    return " ".join(result)


# =============================================================================
# Framework-Specific Class Name Generators
# =============================================================================


def random_traditional_class(rng: random.Random) -> str:
    """Generate traditional semantic class names (Wikipedia, docs style)."""
    prefixes = ["", "mw-", "wiki-", "doc-", "content-", "page-"]
    words = [
        "content", "wrapper", "container", "section", "article", "sidebar",
        "navigation", "header", "footer", "main", "body", "text", "parser-output",
    ]
    modifiers = ["", "-inner", "-outer", "-left", "-right", "-primary", "-secondary"]

    return f"{rng.choice(prefixes)}{rng.choice(words)}{rng.choice(modifiers)}"


def random_bootstrap_classes(rng: random.Random, count: int = 3) -> str:
    """Generate Bootstrap-style utility and component classes."""
    grid_classes = [
        "container", "container-fluid", "row", "col", "col-sm-6", "col-md-4",
        "col-lg-3", "col-xl-2", "col-12", "col-auto", "g-3", "g-4", "gy-4", "gx-3",
    ]
    spacing = [
        "p-0", "p-1", "p-2", "p-3", "p-4", "p-5", "m-0", "m-1", "m-2", "m-3",
        "mt-3", "mb-4", "ms-2", "me-2", "mx-auto", "my-3", "px-4", "py-2",
    ]
    display = [
        "d-none", "d-block", "d-flex", "d-inline", "d-inline-block", "d-grid",
    ]
    flex = [
        "flex-row", "flex-column", "justify-content-center", "justify-content-between",
        "align-items-center", "align-items-start", "flex-wrap", "flex-nowrap",
    ]
    components = [
        "card", "card-body", "card-header", "card-footer", "btn", "btn-primary",
        "btn-secondary", "btn-outline-primary", "navbar", "nav-item", "nav-link",
        "list-group", "list-group-item", "badge", "alert", "alert-info",
    ]
    text = [
        "text-center", "text-start", "text-end", "text-muted", "text-primary",
        "fw-bold", "fw-light", "fs-4", "fs-5", "lh-sm", "lh-lg",
    ]

    all_classes = grid_classes + spacing + display + flex + components + text
    return " ".join(rng.sample(all_classes, min(count, len(all_classes))))


def random_tailwind_classes(rng: random.Random, count: int = 8) -> str:
    """Generate Tailwind CSS utility class explosion."""
    layout = [
        "flex", "inline-flex", "grid", "block", "inline-block", "hidden",
        "flex-col", "flex-row", "flex-wrap", "flex-nowrap",
    ]
    spacing = [
        "p-0", "p-1", "p-2", "p-3", "p-4", "p-6", "p-8", "px-4", "py-2", "py-6",
        "m-0", "m-1", "m-2", "m-4", "mx-auto", "my-4", "mt-2", "mb-4", "ml-2", "mr-2",
        "space-x-2", "space-x-4", "space-y-2", "space-y-4", "gap-2", "gap-4",
    ]
    sizing = [
        "w-full", "w-1/2", "w-1/3", "w-1/4", "w-auto", "w-screen", "w-64", "w-96",
        "h-full", "h-auto", "h-screen", "h-12", "h-16", "h-24", "min-h-screen",
        "max-w-md", "max-w-lg", "max-w-xl", "max-w-2xl", "max-w-7xl",
    ]
    colors = [
        "bg-white", "bg-gray-50", "bg-gray-100", "bg-gray-200", "bg-blue-500",
        "bg-indigo-600", "bg-green-500", "bg-red-500", "bg-yellow-400",
        "text-gray-500", "text-gray-700", "text-gray-900", "text-white",
        "text-blue-600", "text-indigo-600", "border-gray-200", "border-gray-300",
    ]
    typography = [
        "text-xs", "text-sm", "text-base", "text-lg", "text-xl", "text-2xl",
        "font-normal", "font-medium", "font-semibold", "font-bold",
        "leading-tight", "leading-relaxed", "tracking-tight", "tracking-wide",
    ]
    effects = [
        "rounded", "rounded-md", "rounded-lg", "rounded-full", "rounded-none",
        "shadow", "shadow-sm", "shadow-md", "shadow-lg", "shadow-xl",
        "opacity-50", "opacity-75", "opacity-100",
    ]
    borders = [
        "border", "border-0", "border-2", "border-t", "border-b", "border-l", "border-r",
    ]
    interactivity = [
        "cursor-pointer", "cursor-default", "hover:bg-gray-100", "hover:text-blue-600",
        "focus:outline-none", "focus:ring-2", "focus:ring-blue-500",
        "transition", "transition-all", "duration-150", "duration-300",
    ]
    alignment = [
        "items-center", "items-start", "items-end", "justify-center",
        "justify-between", "justify-start", "justify-end", "self-center",
    ]

    all_classes = (
        layout + spacing + sizing + colors + typography +
        effects + borders + interactivity + alignment
    )
    return " ".join(rng.sample(all_classes, min(count, len(all_classes))))


def random_react_class(rng: random.Random) -> str:
    """Generate React/CSS Modules style hashed class names."""
    # CSS Modules pattern: ComponentName_className__hash
    components = [
        "Button", "Card", "Header", "Footer", "Sidebar", "Modal", "Input",
        "Form", "List", "Item", "Container", "Wrapper", "Content", "Title",
    ]
    class_names = [
        "root", "container", "wrapper", "inner", "content", "header",
        "body", "footer", "item", "active", "disabled", "primary",
    ]
    # Generate hash-like suffix
    hash_chars = string.ascii_lowercase + string.digits
    hash_suffix = "".join(rng.choices(hash_chars, k=5))

    component = rng.choice(components)
    class_name = rng.choice(class_names)

    # 50% chance of CSS Modules format, 50% chance of styled-components
    if rng.random() < 0.5:
        return f"{component}_{class_name}__{hash_suffix}"
    else:
        # styled-components format: sc-hash
        return f"sc-{hash_suffix}"


def random_angular_class(rng: random.Random) -> str:
    """Generate Angular-style class names with scoped attributes."""
    material_classes = [
        "mat-button", "mat-raised-button", "mat-card", "mat-card-content",
        "mat-form-field", "mat-input", "mat-select", "mat-option",
        "mat-list", "mat-list-item", "mat-toolbar", "mat-sidenav",
        "mat-icon", "mat-checkbox", "mat-radio-button", "mat-slide-toggle",
    ]
    ng_classes = [
        "ng-star-inserted", "ng-trigger", "ng-animating", "ng-valid",
        "ng-invalid", "ng-pristine", "ng-dirty", "ng-touched", "ng-untouched",
    ]

    if rng.random() < 0.6:
        return rng.choice(material_classes)
    else:
        return rng.choice(ng_classes)


def random_vue_class(rng: random.Random) -> str:
    """Generate Vue-style class names."""
    vue_classes = [
        "v-enter-active", "v-leave-active", "v-enter-from", "v-leave-to",
        "v-move", "fade-enter-active", "fade-leave-active", "slide-fade-enter",
    ]
    component_classes = [
        "vue-component", "v-btn", "v-card", "v-list", "v-list-item",
        "v-container", "v-row", "v-col", "v-app-bar", "v-navigation-drawer",
    ]

    all_classes = vue_classes + component_classes
    return rng.choice(all_classes)


def random_class_for_style(
    rng: random.Random,
    style: HtmlStyle,
    count: int | None = None,
) -> str:
    """Generate class name(s) appropriate for the given HTML style.

    Args:
        rng: Random instance.
        style: The HTML style to generate classes for.
        count: Number of classes (for styles that support multiple).

    Returns:
        Space-separated class names.
    """
    if style == HtmlStyle.TRADITIONAL:
        return random_traditional_class(rng)
    elif style == HtmlStyle.BOOTSTRAP:
        return random_bootstrap_classes(rng, count or 4)
    elif style == HtmlStyle.TAILWIND:
        return random_tailwind_classes(rng, count or 10)
    elif style == HtmlStyle.REACT_SPA:
        # React often has 1-2 classes per element
        classes = [random_react_class(rng) for _ in range(count or 2)]
        return " ".join(classes)
    elif style == HtmlStyle.ANGULAR:
        classes = [random_angular_class(rng) for _ in range(count or 2)]
        return " ".join(classes)
    elif style == HtmlStyle.VUE:
        return random_vue_class(rng)
    else:
        return random_class_name(rng)


def random_data_attributes(rng: random.Random, style: HtmlStyle) -> dict[str, str]:
    """Generate framework-specific data attributes.

    Args:
        rng: Random instance.
        style: The HTML style.

    Returns:
        Dictionary of attribute name -> value pairs.
    """
    attrs = {}
    hash_chars = string.ascii_lowercase + string.digits

    if style == HtmlStyle.REACT_SPA:
        if rng.random() < 0.3:
            attrs["data-reactroot"] = ""
        if rng.random() < 0.4:
            attrs["data-testid"] = f"test-{''.join(rng.choices(hash_chars, k=6))}"

    elif style == HtmlStyle.ANGULAR:
        scope_hash = "".join(rng.choices(hash_chars, k=8))
        attrs[f"_ngcontent-ng-c{rng.randint(100, 999)}"] = ""
        if rng.random() < 0.3:
            attrs["ng-reflect-ng-class"] = rng.choice(["active", "disabled", "primary"])

    elif style == HtmlStyle.VUE:
        vue_hash = "".join(rng.choices(hash_chars, k=7))
        attrs[f"data-v-{vue_hash}"] = ""

    # Common modern attributes
    if rng.random() < 0.2:
        roles = ["main", "navigation", "banner", "contentinfo", "article", "region"]
        attrs["role"] = rng.choice(roles)
    if rng.random() < 0.15:
        attrs["aria-label"] = rng.choice(["Main content", "Navigation", "Close", "Menu"])

    return attrs


def format_attributes(attrs: dict[str, str]) -> str:
    """Format a dictionary of attributes as HTML attribute string.

    Args:
        attrs: Dictionary of attribute name -> value.

    Returns:
        Formatted attribute string (with leading space if non-empty).
    """
    if not attrs:
        return ""

    parts = []
    for name, value in attrs.items():
        if value == "":
            parts.append(name)
        else:
            parts.append(f'{name}="{value}"')

    return " " + " ".join(parts) if parts else ""


# =============================================================================
# HTML Document Chrome (Head, Scripts, Meta Tags)
# =============================================================================


def generate_head_content(
    rng: random.Random,
    style: HtmlStyle,
    title: str = "Page Title",
    complexity: str = "medium",
) -> str:
    """Generate realistic <head> content based on style and complexity.

    Args:
        rng: Random instance.
        style: The HTML style.
        title: Page title.
        complexity: "low", "medium", or "high".

    Returns:
        HTML string for head content (without <head> tags).
    """
    parts = [
        '<meta charset="utf-8">',
        f"<title>{title}</title>",
    ]

    # Basic meta tags (all complexity levels)
    parts.append('<meta name="viewport" content="width=device-width, initial-scale=1.0">')

    if complexity in ("medium", "high"):
        description = rng.choice([
            "Welcome to our website with great content.",
            "Find the best products and services here.",
            "Your source for quality information.",
            "Discover amazing content on our platform.",
        ])
        parts.append(f'<meta name="description" content="{description}">')
        parts.append('<meta name="robots" content="index, follow">')

    if complexity == "high":
        # Open Graph tags
        parts.extend([
            f'<meta property="og:title" content="{title}">',
            '<meta property="og:type" content="website">',
            '<meta property="og:url" content="https://example.com/page">',
            '<meta property="og:image" content="https://example.com/image.jpg">',
            # Twitter cards
            '<meta name="twitter:card" content="summary_large_image">',
            f'<meta name="twitter:title" content="{title}">',
        ])

    # Style-specific assets
    if style == HtmlStyle.TRADITIONAL:
        parts.append('<link rel="stylesheet" href="/static/styles.css">')

    elif style == HtmlStyle.BOOTSTRAP:
        parts.extend([
            '<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">',
        ])
        if complexity in ("medium", "high"):
            parts.append('<link rel="stylesheet" href="/static/custom.css">')

    elif style == HtmlStyle.TAILWIND:
        parts.append('<script src="https://cdn.tailwindcss.com"></script>')

    elif style == HtmlStyle.REACT_SPA:
        parts.extend([
            '<link rel="stylesheet" href="/static/main.css">',
            '<script defer src="/static/bundle.js"></script>',
        ])

    elif style == HtmlStyle.ANGULAR:
        parts.extend([
            '<link rel="stylesheet" href="styles.css">',
            '<script src="runtime.js" defer></script>',
            '<script src="polyfills.js" defer></script>',
            '<script src="main.js" defer></script>',
        ])

    elif style == HtmlStyle.VUE:
        parts.extend([
            '<link rel="stylesheet" href="/css/app.css">',
            '<script type="module" src="/js/app.js"></script>',
        ])

    # Favicon
    if complexity in ("medium", "high"):
        parts.append('<link rel="icon" href="/favicon.ico">')

    # Analytics (high complexity only)
    if complexity == "high":
        analytics_snippet = '''<script async src="https://www.googletagmanager.com/gtag/js?id=GA_MEASUREMENT_ID"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'GA_MEASUREMENT_ID');
</script>'''
        parts.append(analytics_snippet)

    return "\n    ".join(parts)


def generate_navigation(rng: random.Random, style: HtmlStyle) -> str:
    """Generate style-appropriate navigation markup.

    Args:
        rng: Random instance.
        style: The HTML style.

    Returns:
        HTML string for navigation.
    """
    nav_items = rng.sample(
        ["Home", "About", "Products", "Services", "Blog", "Contact", "FAQ", "Support"],
        k=rng.randint(4, 6),
    )

    if style == HtmlStyle.TRADITIONAL:
        links = "\n        ".join(
            f'<li><a href="/{item.lower()}">{item}</a></li>' for item in nav_items
        )
        return f'''<nav class="main-navigation">
    <ul class="nav-list">
        {links}
    </ul>
</nav>'''

    elif style == HtmlStyle.BOOTSTRAP:
        links = "\n            ".join(
            f'<li class="nav-item"><a class="nav-link" href="/{item.lower()}">{item}</a></li>'
            for item in nav_items
        )
        return f'''<nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container-fluid">
        <a class="navbar-brand" href="#">Brand</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            {links}
            </ul>
        </div>
    </div>
</nav>'''

    elif style == HtmlStyle.TAILWIND:
        links = "\n                ".join(
            f'<a href="/{item.lower()}" class="text-gray-700 hover:text-blue-600 px-3 py-2">{item}</a>'
            for item in nav_items
        )
        return f'''<nav class="bg-white shadow-sm">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex justify-between h-16">
            <div class="flex items-center">
                <span class="text-xl font-bold text-gray-900">Brand</span>
            </div>
            <div class="hidden md:flex items-center space-x-4">
                {links}
            </div>
        </div>
    </div>
</nav>'''

    elif style == HtmlStyle.REACT_SPA:
        links = "\n            ".join(
            f'<a href="/{item.lower()}" class="NavLink_item__x7k2j">{item}</a>'
            for item in nav_items
        )
        return f'''<nav class="Navigation_root__abc12" data-testid="main-nav">
    <div class="Navigation_container__def34">
        <div class="Navigation_brand__ghi56">Brand</div>
        <div class="Navigation_links__jkl78">
            {links}
        </div>
    </div>
</nav>'''

    elif style == HtmlStyle.ANGULAR:
        links = "\n            ".join(
            f'<a mat-button routerLink="/{item.lower()}">{item}</a>' for item in nav_items
        )
        return f'''<mat-toolbar color="primary" _ngcontent-ng-c123>
    <span>Brand</span>
    <span class="spacer"></span>
    <nav _ngcontent-ng-c124>
        {links}
    </nav>
</mat-toolbar>'''

    elif style == HtmlStyle.VUE:
        links = "\n            ".join(
            f'<router-link to="/{item.lower()}" class="nav-link" data-v-abc1234>{item}</router-link>'
            for item in nav_items
        )
        return f'''<nav class="v-navigation-drawer" data-v-abc1234>
    <div class="v-list" data-v-abc1234>
        {links}
    </div>
</nav>'''

    return ""


def generate_footer(rng: random.Random, style: HtmlStyle) -> str:
    """Generate style-appropriate footer markup.

    Args:
        rng: Random instance.
        style: The HTML style.

    Returns:
        HTML string for footer.
    """
    year = rng.randint(2020, 2025)
    company = rng.choice(["Acme Corp", "Example Inc", "Demo LLC", "Sample Co"])

    if style == HtmlStyle.TRADITIONAL:
        return f'''<footer class="site-footer">
    <div class="footer-content">
        <p>&copy; {year} {company}. All rights reserved.</p>
        <nav class="footer-nav">
            <a href="/privacy">Privacy Policy</a>
            <a href="/terms">Terms of Service</a>
        </nav>
    </div>
</footer>'''

    elif style == HtmlStyle.BOOTSTRAP:
        return f'''<footer class="bg-light py-4 mt-auto">
    <div class="container">
        <div class="row">
            <div class="col-md-6">
                <p class="text-muted mb-0">&copy; {year} {company}</p>
            </div>
            <div class="col-md-6 text-md-end">
                <a href="/privacy" class="text-muted me-3">Privacy</a>
                <a href="/terms" class="text-muted">Terms</a>
            </div>
        </div>
    </div>
</footer>'''

    elif style == HtmlStyle.TAILWIND:
        return f'''<footer class="bg-gray-100 border-t border-gray-200">
    <div class="max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
        <div class="flex flex-col md:flex-row justify-between items-center">
            <p class="text-gray-500 text-sm">&copy; {year} {company}</p>
            <div class="flex space-x-6 mt-4 md:mt-0">
                <a href="/privacy" class="text-gray-400 hover:text-gray-500 text-sm">Privacy</a>
                <a href="/terms" class="text-gray-400 hover:text-gray-500 text-sm">Terms</a>
            </div>
        </div>
    </div>
</footer>'''

    elif style in (HtmlStyle.REACT_SPA, HtmlStyle.ANGULAR, HtmlStyle.VUE):
        class_suffix = "".join(rng.choices(string.ascii_lowercase, k=5))
        return f'''<footer class="Footer_root__{class_suffix}">
    <div class="Footer_container__{class_suffix}">
        <p>&copy; {year} {company}</p>
    </div>
</footer>'''

    return f"<footer>Footer content</footer>"


def wrap_with_realistic_chrome(
    body_content: str,
    style: HtmlStyle,
    rng: random.Random,
    title: str = "Page Title",
    complexity: str = "medium",
    include_nav: bool = True,
    include_footer: bool = True,
    target_size: int | None = None,
) -> str:
    """Wrap body content with realistic HTML document structure.

    This function takes minimal body content (like a target element) and
    wraps it with realistic HTML chrome including head content, navigation,
    main wrapper, and footer based on the specified framework style.

    Args:
        body_content: The core content to wrap.
        style: The HTML framework style to use.
        rng: Random instance for deterministic generation.
        title: Page title.
        complexity: "low", "medium", "high", or "realistic".
            - low: ~2KB, minimal chrome
            - medium: ~3KB, standard chrome
            - high: ~4KB, full meta tags and analytics
            - realistic: 50KB+, matches real website sizes
        include_nav: Whether to include navigation.
        include_footer: Whether to include footer.
        target_size: Optional explicit target size for "realistic" mode.

    Returns:
        Complete HTML document string.
    """
    # For realistic complexity, treat as "high" for head content
    head_complexity = "high" if complexity == "realistic" else complexity
    head_content = generate_head_content(rng, style, title, head_complexity)

    # Build body parts
    body_parts = []

    if include_nav:
        body_parts.append(generate_navigation(rng, style))

    # Main content wrapper based on style
    if style == HtmlStyle.TRADITIONAL:
        body_parts.append(f'''<main class="main-content" role="main">
    <article class="page-article">
        {body_content}
    </article>
</main>''')

    elif style == HtmlStyle.BOOTSTRAP:
        body_parts.append(f'''<main class="container py-4">
    <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
            {body_content}
        </div>
    </div>
</main>''')

    elif style == HtmlStyle.TAILWIND:
        body_parts.append(f'''<main class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <div class="bg-white rounded-lg shadow-sm p-6">
        {body_content}
    </div>
</main>''')

    elif style == HtmlStyle.REACT_SPA:
        body_parts.append(f'''<div id="root" data-reactroot>
    <main class="App_main__xyz12">
        <div class="Content_wrapper__abc34">
            {body_content}
        </div>
    </main>
</div>''')

    elif style == HtmlStyle.ANGULAR:
        body_parts.append(f'''<app-root _nghost-ng-c100>
    <main class="mat-app-background" _ngcontent-ng-c101>
        <div class="content-wrapper" _ngcontent-ng-c102>
            {body_content}
        </div>
    </main>
</app-root>''')

    elif style == HtmlStyle.VUE:
        body_parts.append(f'''<div id="app" data-v-app>
    <main class="v-main" data-v-main>
        <div class="v-container" data-v-container>
            {body_content}
        </div>
    </main>
</div>''')

    else:
        body_parts.append(f"<main>{body_content}</main>")

    if include_footer:
        body_parts.append(generate_footer(rng, style))

    # For realistic complexity, add bulk content to reach target size
    if complexity == "realistic":
        # Default target: 50KB-100KB (matches real website median)
        actual_target = target_size or rng.randint(50000, 100000)

        # Add sidebar
        body_parts.insert(1, generate_sidebar_content(rng, style, items=25))

        # Add product grid or comments after main content
        if rng.random() < 0.5:
            body_parts.insert(-1, generate_product_grid(rng, style, count=12))
        else:
            body_parts.insert(-1, generate_comments_section(rng, style, count=15))

        # Generate additional bulk to reach target
        current_size = sum(len(p) for p in body_parts)
        if current_size < actual_target:
            bulk = generate_bulk_noise(rng, style, target_size=actual_target - current_size)
            body_parts.insert(-1, bulk)

        # Apply deep nesting to main content area
        for i, part in enumerate(body_parts):
            if "<main" in part or "<article" in part:
                body_parts[i] = generate_deep_nested_wrapper(
                    part, rng, style, depth=rng.randint(8, 15)
                )
                break

    body_html = "\n".join(body_parts)

    # Assemble full document
    return f'''<!DOCTYPE html>
<html lang="en">
<head>
    {head_content}
</head>
<body>
{body_html}
</body>
</html>'''


# =============================================================================
# Bulk Content Generators (for realistic HTML sizes)
# =============================================================================


def generate_sidebar_content(rng: random.Random, style: HtmlStyle, items: int = 20) -> str:
    """Generate sidebar content with links, widgets, and noise.

    Real websites have sidebars with 20-50 links, widgets, ads, etc.
    This adds realistic bulk to HTML documents.

    Args:
        rng: Random instance.
        style: The HTML style.
        items: Number of sidebar items to generate.

    Returns:
        HTML string for sidebar content.
    """
    # Recent posts/articles section
    recent_titles = [random_paragraph(rng, sentences=1).split('.')[0] for _ in range(items // 2)]
    recent_items = "\n".join(
        f'<li class="{random_class_for_style(rng, style, 2)}"><a href="/post/{i}">{title}</a></li>'
        for i, title in enumerate(recent_titles)
    )

    # Categories section
    categories = ["Technology", "Business", "Health", "Science", "Entertainment",
                  "Sports", "Travel", "Food", "Fashion", "Finance"]
    cat_items = "\n".join(
        f'<li class="{random_class_for_style(rng, style, 2)}"><a href="/category/{cat.lower()}">{cat}</a> <span>({rng.randint(5, 50)})</span></li>'
        for cat in rng.sample(categories, min(len(categories), items // 3))
    )

    # Tags cloud
    tags = ["python", "javascript", "react", "vue", "angular", "css", "html",
            "nodejs", "django", "flask", "aws", "docker", "kubernetes", "ml", "ai"]
    tag_items = " ".join(
        f'<a href="/tag/{tag}" class="{random_class_for_style(rng, style, 3)}">{tag}</a>'
        for tag in rng.sample(tags, min(len(tags), items // 2))
    )

    # Archive section
    months = ["January", "February", "March", "April", "May", "June",
              "July", "August", "September", "October", "November", "December"]
    archive_items = "\n".join(
        f'<li><a href="/archive/2024/{i+1:02d}">{month} 2024</a></li>'
        for i, month in enumerate(months[:items // 3])
    )

    if style == HtmlStyle.BOOTSTRAP:
        return f'''<aside class="col-lg-4">
    <div class="card mb-4">
        <div class="card-header">Recent Posts</div>
        <ul class="list-group list-group-flush">
            {recent_items}
        </ul>
    </div>
    <div class="card mb-4">
        <div class="card-header">Categories</div>
        <ul class="list-group list-group-flush">
            {cat_items}
        </ul>
    </div>
    <div class="card mb-4">
        <div class="card-header">Tags</div>
        <div class="card-body">
            {tag_items}
        </div>
    </div>
    <div class="card mb-4">
        <div class="card-header">Archive</div>
        <ul class="list-group list-group-flush">
            {archive_items}
        </ul>
    </div>
</aside>'''

    elif style == HtmlStyle.TAILWIND:
        return f'''<aside class="w-full lg:w-1/4 px-4">
    <div class="bg-white rounded-lg shadow-sm p-4 mb-4">
        <h3 class="text-lg font-semibold mb-3">Recent Posts</h3>
        <ul class="space-y-2">
            {recent_items}
        </ul>
    </div>
    <div class="bg-white rounded-lg shadow-sm p-4 mb-4">
        <h3 class="text-lg font-semibold mb-3">Categories</h3>
        <ul class="space-y-2">
            {cat_items}
        </ul>
    </div>
    <div class="bg-white rounded-lg shadow-sm p-4 mb-4">
        <h3 class="text-lg font-semibold mb-3">Tags</h3>
        <div class="flex flex-wrap gap-2">
            {tag_items}
        </div>
    </div>
</aside>'''

    else:
        return f'''<aside class="sidebar">
    <section class="widget">
        <h3>Recent Posts</h3>
        <ul>{recent_items}</ul>
    </section>
    <section class="widget">
        <h3>Categories</h3>
        <ul>{cat_items}</ul>
    </section>
    <section class="widget">
        <h3>Tags</h3>
        <div class="tag-cloud">{tag_items}</div>
    </section>
    <section class="widget">
        <h3>Archive</h3>
        <ul>{archive_items}</ul>
    </section>
</aside>'''


def generate_product_grid(rng: random.Random, style: HtmlStyle, count: int = 12) -> str:
    """Generate e-commerce style product grid.

    Real e-commerce sites have grids of 12-48 products with images,
    titles, prices, ratings, etc. This adds significant bulk.

    Args:
        rng: Random instance.
        style: The HTML style.
        count: Number of products.

    Returns:
        HTML string for product grid.
    """
    products = []
    for i in range(count):
        name = random_product_name(rng)
        price = random_price(rng)
        rating = round(rng.uniform(3.0, 5.0), 1)
        reviews = rng.randint(10, 500)
        desc = random_paragraph(rng, sentences=2)

        if style == HtmlStyle.BOOTSTRAP:
            product = f'''<div class="col-md-4 col-sm-6 mb-4">
    <div class="card h-100">
        <img src="/images/product-{i}.jpg" class="card-img-top" alt="{name}">
        <div class="card-body">
            <h5 class="card-title">{name}</h5>
            <p class="card-text text-muted">{desc}</p>
            <div class="d-flex justify-content-between align-items-center">
                <span class="h5 mb-0">{price}</span>
                <span class="badge bg-warning text-dark">{rating} ({reviews})</span>
            </div>
        </div>
        <div class="card-footer">
            <button class="btn btn-primary w-100">Add to Cart</button>
        </div>
    </div>
</div>'''

        elif style == HtmlStyle.TAILWIND:
            product = f'''<div class="bg-white rounded-lg shadow-sm overflow-hidden">
    <img src="/images/product-{i}.jpg" class="w-full h-48 object-cover" alt="{name}">
    <div class="p-4">
        <h3 class="text-lg font-semibold text-gray-900">{name}</h3>
        <p class="text-sm text-gray-500 mt-1">{desc}</p>
        <div class="flex justify-between items-center mt-4">
            <span class="text-xl font-bold text-gray-900">{price}</span>
            <span class="text-sm text-yellow-600">{rating} ({reviews} reviews)</span>
        </div>
        <button class="mt-4 w-full bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700">
            Add to Cart
        </button>
    </div>
</div>'''

        else:
            product = f'''<div class="product-card">
    <img src="/images/product-{i}.jpg" alt="{name}">
    <div class="product-info">
        <h3 class="product-title">{name}</h3>
        <p class="product-desc">{desc}</p>
        <span class="product-price">{price}</span>
        <span class="product-rating">{rating} ({reviews})</span>
        <button class="add-to-cart">Add to Cart</button>
    </div>
</div>'''

        products.append(product)

    grid_class = {
        HtmlStyle.BOOTSTRAP: "row",
        HtmlStyle.TAILWIND: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6",
    }.get(style, "product-grid")

    return f'<div class="{grid_class}">\n{"".join(products)}\n</div>'


def generate_comments_section(rng: random.Random, style: HtmlStyle, count: int = 10) -> str:
    """Generate comments section with nested replies.

    Real websites have comment sections with 5-50 comments,
    nested replies, avatars, timestamps, etc.

    Args:
        rng: Random instance.
        style: The HTML style.
        count: Number of comments.

    Returns:
        HTML string for comments section.
    """
    comments = []
    for i in range(count):
        author = random_person_name(rng)
        date = random_date(rng)
        content = random_paragraph(rng, sentences=rng.randint(2, 5))
        likes = rng.randint(0, 50)

        # Sometimes add nested replies
        replies_html = ""
        if rng.random() < 0.3:
            reply_author = random_person_name(rng)
            reply_content = random_paragraph(rng, sentences=rng.randint(1, 3))
            if style == HtmlStyle.BOOTSTRAP:
                replies_html = f'''<div class="ms-4 mt-3 p-3 bg-light rounded">
    <div class="d-flex">
        <img src="/avatars/default.jpg" class="rounded-circle me-2" width="32" height="32">
        <div>
            <strong>{reply_author}</strong> <small class="text-muted">in reply</small>
            <p class="mb-0">{reply_content}</p>
        </div>
    </div>
</div>'''
            else:
                replies_html = f'''<div class="comment-reply">
    <img src="/avatars/default.jpg" class="avatar-small">
    <div class="reply-content">
        <strong>{reply_author}</strong>
        <p>{reply_content}</p>
    </div>
</div>'''

        if style == HtmlStyle.BOOTSTRAP:
            comment = f'''<div class="card mb-3">
    <div class="card-body">
        <div class="d-flex">
            <img src="/avatars/user-{i}.jpg" class="rounded-circle me-3" width="48" height="48">
            <div class="flex-grow-1">
                <div class="d-flex justify-content-between">
                    <strong>{author}</strong>
                    <small class="text-muted">{date}</small>
                </div>
                <p class="mt-2">{content}</p>
                <div class="d-flex gap-3">
                    <a href="#" class="text-decoration-none"><i class="bi bi-hand-thumbs-up"></i> {likes}</a>
                    <a href="#" class="text-decoration-none">Reply</a>
                </div>
                {replies_html}
            </div>
        </div>
    </div>
</div>'''

        elif style == HtmlStyle.TAILWIND:
            comment = f'''<div class="bg-white rounded-lg shadow-sm p-4 mb-4">
    <div class="flex">
        <img src="/avatars/user-{i}.jpg" class="w-12 h-12 rounded-full mr-4">
        <div class="flex-1">
            <div class="flex justify-between items-center">
                <span class="font-semibold">{author}</span>
                <span class="text-sm text-gray-500">{date}</span>
            </div>
            <p class="mt-2 text-gray-700">{content}</p>
            <div class="flex gap-4 mt-3 text-sm">
                <button class="text-gray-500 hover:text-blue-600">Like ({likes})</button>
                <button class="text-gray-500 hover:text-blue-600">Reply</button>
            </div>
            {replies_html}
        </div>
    </div>
</div>'''

        else:
            comment = f'''<div class="comment">
    <img src="/avatars/user-{i}.jpg" class="avatar">
    <div class="comment-body">
        <div class="comment-header">
            <span class="author">{author}</span>
            <span class="date">{date}</span>
        </div>
        <p class="comment-text">{content}</p>
        <div class="comment-actions">
            <a href="#">Like ({likes})</a>
            <a href="#">Reply</a>
        </div>
        {replies_html}
    </div>
</div>'''

        comments.append(comment)

    return f'''<section class="comments-section">
    <h3>Comments ({count})</h3>
    {"".join(comments)}
</section>'''


def generate_deep_nested_wrapper(
    content: str,
    rng: random.Random,
    style: HtmlStyle,
    depth: int = 10,
) -> str:
    """Wrap content in deeply nested div structure.

    Real websites have average nesting depth of 25 levels.
    This adds realistic structural complexity.

    Args:
        content: Content to wrap.
        rng: Random instance.
        style: The HTML style.
        depth: How many levels to nest.

    Returns:
        Deeply nested HTML string.
    """
    result = content
    for i in range(depth):
        class_attr = random_class_for_style(rng, style, count=rng.randint(1, 4))
        data_attrs = format_attributes(random_data_attributes(rng, style))
        result = f'<div class="{class_attr}"{data_attrs}>\n{result}\n</div>'
    return result


def generate_bulk_noise(rng: random.Random, style: HtmlStyle, target_size: int = 50000) -> str:
    """Generate bulk noise content to reach target HTML size.

    This combines various content types to build up to a target size,
    making the HTML more realistic.

    Args:
        rng: Random instance.
        style: The HTML style.
        target_size: Target HTML size in characters.

    Returns:
        HTML string of bulk content.
    """
    parts = []
    current_size = 0

    generators = [
        lambda: generate_product_grid(rng, style, count=rng.randint(6, 12)),
        lambda: generate_comments_section(rng, style, count=rng.randint(5, 15)),
        lambda: generate_sidebar_content(rng, style, items=rng.randint(15, 30)),
        lambda: "".join(
            f'<div class="{random_class_for_style(rng, style, 4)}">{random_paragraph(rng, rng.randint(3, 8))}</div>'
            for _ in range(rng.randint(5, 10))
        ),
    ]

    while current_size < target_size:
        generator = rng.choice(generators)
        chunk = generator()
        parts.append(chunk)
        current_size += len(chunk)

    return "\n".join(parts)
