from __future__ import annotations

"""Base generator infrastructure for BeautifulSoup RL environment.

This module provides the foundational classes and utilities for task generation:
- TaskInstance: The data structure representing a single task
- Generator: The protocol that all archetype generators must follow
- RNG utilities: Deterministic random number generation
- HTML noise helpers: Functions to add realistic noise to HTML
"""

import hashlib
import random
import re
import string
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any, Sequence


@dataclass
class TaskInstance:
    """A single task instance generated by an archetype generator.

    Attributes:
        html: The HTML content to be parsed.
        query: Natural language description of what to extract.
        ground_truth: The expected correct answer (hidden from model).
        archetype_id: The archetype that generated this instance.
        seed: The seed used to generate this instance.
        solvable: Whether this task is solvable with BS4.
        answer_schema: JSON schema for the expected answer format.
        normalization: Rules for normalizing the answer before comparison.
        limit_info: For limitation tasks, the valid reasons and evidence patterns.
        safety_info: Forbidden patterns and fields to check for safety violations.
        metadata: Additional metadata for analysis and debugging.
    """

    html: str
    query: str
    ground_truth: Any
    archetype_id: str
    seed: int
    solvable: bool = True
    answer_schema: dict = field(default_factory=dict)
    normalization: dict = field(default_factory=lambda: {
        "strip_whitespace": True,
        "collapse_whitespace": True,
        "unicode_nfc": True,
        "sort_lists": False,
        "sort_dict_keys": True,
    })
    limit_info: dict = field(default_factory=lambda: {
        "allowed_reasons": [],
        "evidence_patterns": [],
    })
    safety_info: dict = field(default_factory=lambda: {
        "forbidden_patterns": [],
        "forbidden_fields": [],
    })
    metadata: dict = field(default_factory=dict)

    def to_info_dict(self) -> dict[str, Any]:
        """Convert to the info dict format used in dataset rows.

        Returns:
            Dictionary with all task information for grading.
        """
        return {
            "archetype_id": self.archetype_id,
            "seed": self.seed,
            "solvable": self.solvable,
            "ground_truth": self.ground_truth,
            "answer_schema": self.answer_schema,
            "normalization": self.normalization,
            "limit_info": self.limit_info,
            "safety_info": self.safety_info,
            "metadata": self.metadata,
        }


class Generator(ABC):
    """Abstract base class for task generators.

    Each archetype implements this protocol to generate task instances.
    Generators must be deterministic: same seed -> same output.
    """

    # Set by @register decorator
    _archetype_spec: Any = None

    @property
    def archetype_id(self) -> str:
        """Get the archetype ID from the registered spec."""
        if self._archetype_spec is None:
            raise RuntimeError(
                f"{self.__class__.__name__} was not registered with @register"
            )
        return self._archetype_spec.archetype_id

    @abstractmethod
    def generate(self, seed: int) -> TaskInstance:
        """Generate a task instance from a seed.

        This method must be deterministic: the same seed must always
        produce the same task instance.

        Args:
            seed: Integer seed for reproducible generation.

        Returns:
            A TaskInstance with all required fields populated.
        """
        pass


def stable_int_seed(split: str, archetype_id: str, seed: int) -> int:
    """Generate a stable integer seed from split, archetype, and seed.

    Uses SHA-256 to combine inputs into a deterministic integer.
    This avoids Python's salted hash() which is not reproducible across runs.

    Args:
        split: The dataset split (train, eval, bench).
        archetype_id: The archetype identifier.
        seed: The base seed value.

    Returns:
        A stable integer seed suitable for random.Random().
    """
    data = f"{split}:{archetype_id}:{seed}".encode("utf-8")
    hash_bytes = hashlib.sha256(data).digest()
    # Use first 8 bytes as a 64-bit integer
    return int.from_bytes(hash_bytes[:8], byteorder="big")


def make_rng(archetype_id: str, seed: int, split: str = "train") -> random.Random:
    """Create a seeded random.Random instance for a task.

    Args:
        archetype_id: The archetype identifier.
        seed: The base seed value.
        split: The dataset split (default "train").

    Returns:
        A seeded random.Random instance.
    """
    stable_seed = stable_int_seed(split, archetype_id, seed)
    return random.Random(stable_seed)


# =============================================================================
# HTML Noise and Variation Helpers
# =============================================================================


def random_whitespace(rng: random.Random, min_len: int = 1, max_len: int = 3) -> str:
    """Generate random whitespace string.

    Args:
        rng: Random instance.
        min_len: Minimum length.
        max_len: Maximum length.

    Returns:
        String of random whitespace characters.
    """
    length = rng.randint(min_len, max_len)
    chars = [" ", "\t", "\n"]
    weights = [0.7, 0.2, 0.1]
    return "".join(rng.choices(chars, weights=weights, k=length))


def add_noise_comments(html: str, rng: random.Random, count: int = 3) -> str:
    """Add random HTML comments to the document.

    Args:
        html: The HTML string.
        rng: Random instance.
        count: Number of comments to add.

    Returns:
        HTML with added comments.
    """
    comments = [
        "<!-- TODO: fix this -->",
        "<!-- legacy code -->",
        "<!-- generated by cms -->",
        "<!-- analytics tag -->",
        "<!-- do not modify -->",
        "<!-- end section -->",
        "<!-- begin content -->",
        "<!-- version 2.1 -->",
    ]

    for _ in range(count):
        comment = rng.choice(comments)
        # Find a random position to insert (after a tag close)
        positions = [m.end() for m in re.finditer(r">", html)]
        if positions:
            pos = rng.choice(positions)
            html = html[:pos] + comment + html[pos:]

    return html


def randomize_attribute_order(tag: str, rng: random.Random) -> str:
    """Randomize the order of attributes in an HTML tag.

    Args:
        tag: An HTML tag string like '<div class="foo" id="bar">'.
        rng: Random instance.

    Returns:
        The tag with attributes in random order.
    """
    # Parse the tag
    match = re.match(r"<(\w+)((?:\s+[^>]*)?)\s*/?>", tag)
    if not match:
        return tag

    tag_name = match.group(1)
    attrs_str = match.group(2).strip()

    if not attrs_str:
        return tag

    # Extract attributes
    attr_pattern = r'(\w+)(?:=(?:"([^"]*)"|\'([^\']*)\'|(\S+)))?'
    attrs = re.findall(attr_pattern, attrs_str)

    if len(attrs) <= 1:
        return tag

    # Shuffle attributes
    rng.shuffle(attrs)

    # Reconstruct
    attr_strs = []
    for name, val_dq, val_sq, val_bare in attrs:
        if val_dq:
            attr_strs.append(f'{name}="{val_dq}"')
        elif val_sq:
            attr_strs.append(f"{name}='{val_sq}'")
        elif val_bare:
            attr_strs.append(f"{name}={val_bare}")
        else:
            attr_strs.append(name)

    is_self_closing = tag.rstrip().endswith("/>")
    closing = "/>" if is_self_closing else ">"
    return f"<{tag_name} {' '.join(attr_strs)}{closing}"


def add_decoy_elements(
    html: str,
    rng: random.Random,
    decoys: Sequence[str] | None = None,
    count: int = 2,
) -> str:
    """Add decoy elements that might distract naive extractors.

    Args:
        html: The HTML string.
        rng: Random instance.
        decoys: List of decoy HTML snippets. If None, uses defaults.
        count: Number of decoys to add.

    Returns:
        HTML with added decoy elements.
    """
    if decoys is None:
        decoys = [
            '<div class="hidden" style="display:none">decoy content</div>',
            '<span class="sr-only">screen reader only</span>',
            '<noscript>Enable JavaScript</noscript>',
            '<template id="tmpl">template content</template>',
            '<!-- <div class="old">deprecated</div> -->',
        ]

    for _ in range(count):
        decoy = rng.choice(decoys)
        # Insert before </body> if present, otherwise at end
        if "</body>" in html:
            html = html.replace("</body>", f"{decoy}</body>", 1)
        else:
            html += decoy

    return html


def random_class_name(rng: random.Random, prefix: str = "") -> str:
    """Generate a random CSS class name.

    Args:
        rng: Random instance.
        prefix: Optional prefix for the class name.

    Returns:
        A random class name string.
    """
    suffixes = ["container", "wrapper", "content", "item", "box", "section", "main"]
    modifiers = ["primary", "secondary", "active", "hidden", "new", "old", "v2"]

    parts = [prefix] if prefix else []
    parts.append(rng.choice(suffixes))
    if rng.random() < 0.5:
        parts.append(rng.choice(modifiers))
    if rng.random() < 0.3:
        parts.append(str(rng.randint(1, 99)))

    return "-".join(parts)


def random_id(rng: random.Random, prefix: str = "") -> str:
    """Generate a random HTML ID.

    Args:
        rng: Random instance.
        prefix: Optional prefix for the ID.

    Returns:
        A random ID string.
    """
    base = prefix or rng.choice(["el", "node", "item", "block", "comp"])
    suffix = "".join(rng.choices(string.ascii_lowercase + string.digits, k=6))
    return f"{base}-{suffix}"


def introduce_malformation(
    html: str,
    rng: random.Random,
    malformation_type: str | None = None,
) -> str:
    """Introduce a specific type of HTML malformation.

    Args:
        html: The HTML string.
        rng: Random instance.
        malformation_type: Type of malformation. If None, chooses randomly.
            Options: "unclosed_tag", "missing_quotes", "bad_nesting"

    Returns:
        Malformed HTML string.
    """
    if malformation_type is None:
        malformation_type = rng.choice(["unclosed_tag", "missing_quotes", "bad_nesting"])

    if malformation_type == "unclosed_tag":
        # Remove a closing tag
        closing_tags = list(re.finditer(r"</(\w+)>", html))
        if closing_tags:
            match = rng.choice(closing_tags)
            html = html[: match.start()] + html[match.end() :]

    elif malformation_type == "missing_quotes":
        # Remove quotes from an attribute value (if value has no spaces)
        attr_pattern = r'(\w+)="([^"\s]+)"'
        matches = list(re.finditer(attr_pattern, html))
        if matches:
            match = rng.choice(matches)
            replacement = f"{match.group(1)}={match.group(2)}"
            html = html[: match.start()] + replacement + html[match.end() :]

    elif malformation_type == "bad_nesting":
        # Create overlapping tags (e.g., <b><i>text</b></i>)
        # This is tricky to do safely, so we just add a known bad pattern
        bad_patterns = [
            "<b><i>overlapped</b></i>",
            "<p><div>block in inline</div></p>",
        ]
        pattern = rng.choice(bad_patterns)
        if "</body>" in html:
            html = html.replace("</body>", f"{pattern}</body>", 1)
        else:
            html += pattern

    return html


# =============================================================================
# Content Generation Helpers
# =============================================================================


def random_person_name(rng: random.Random) -> str:
    """Generate a random person name."""
    first_names = [
        "Alice", "Bob", "Carol", "David", "Emma", "Frank", "Grace", "Henry",
        "Ivy", "Jack", "Karen", "Leo", "Maria", "Nathan", "Olivia", "Peter",
    ]
    last_names = [
        "Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia", "Miller",
        "Davis", "Martinez", "Anderson", "Wilson", "Taylor", "Thomas", "Lee",
    ]
    return f"{rng.choice(first_names)} {rng.choice(last_names)}"


def random_company_name(rng: random.Random) -> str:
    """Generate a random company name."""
    prefixes = ["Acme", "Global", "Tech", "Prime", "Alpha", "Omega", "Nova", "Apex"]
    suffixes = ["Corp", "Inc", "LLC", "Solutions", "Systems", "Industries", "Labs"]
    return f"{rng.choice(prefixes)} {rng.choice(suffixes)}"


def random_product_name(rng: random.Random) -> str:
    """Generate a random product name."""
    adjectives = ["Super", "Ultra", "Pro", "Max", "Plus", "Elite", "Premium"]
    nouns = ["Widget", "Gadget", "Tool", "Device", "System", "Kit", "Set"]
    return f"{rng.choice(adjectives)} {rng.choice(nouns)}"


def random_price(rng: random.Random, min_val: float = 9.99, max_val: float = 999.99) -> str:
    """Generate a random price string."""
    value = rng.uniform(min_val, max_val)
    return f"${value:.2f}"


def random_date(rng: random.Random) -> str:
    """Generate a random date string in various formats."""
    year = rng.randint(2020, 2025)
    month = rng.randint(1, 12)
    day = rng.randint(1, 28)  # Safe for all months

    formats = [
        f"{year}-{month:02d}-{day:02d}",
        f"{month:02d}/{day:02d}/{year}",
        f"{day:02d}.{month:02d}.{year}",
    ]
    return rng.choice(formats)


def random_url(rng: random.Random, base: str = "https://example.com") -> str:
    """Generate a random URL."""
    paths = ["products", "about", "contact", "blog", "news", "help", "faq"]
    slugs = ["item", "page", "post", "article", "entry"]
    return f"{base}/{rng.choice(paths)}/{rng.choice(slugs)}-{rng.randint(1, 999)}"


def random_email(rng: random.Random) -> str:
    """Generate a random email address."""
    names = ["user", "contact", "info", "hello", "support", "admin"]
    domains = ["example.com", "test.org", "sample.net", "demo.io"]
    return f"{rng.choice(names)}{rng.randint(1, 999)}@{rng.choice(domains)}"


def random_paragraph(rng: random.Random, sentences: int = 3) -> str:
    """Generate a random paragraph of lorem ipsum-like text."""
    sentence_templates = [
        "The {adj} {noun} {verb} the {noun2}.",
        "A {noun} was {verb} by the {adj} {noun2}.",
        "Several {adj} {noun}s {verb} near the {noun2}.",
        "The {noun} appeared to be {adj} and {verb}.",
    ]
    adjectives = ["quick", "lazy", "bright", "dark", "small", "large", "old", "new"]
    nouns = ["fox", "dog", "cat", "bird", "tree", "house", "car", "book"]
    verbs = ["jumped", "ran", "walked", "flew", "sat", "stood", "moved", "rested"]

    result = []
    for _ in range(sentences):
        template = rng.choice(sentence_templates)
        sentence = template.format(
            adj=rng.choice(adjectives),
            noun=rng.choice(nouns),
            noun2=rng.choice(nouns),
            verb=rng.choice(verbs),
        )
        result.append(sentence)

    return " ".join(result)
