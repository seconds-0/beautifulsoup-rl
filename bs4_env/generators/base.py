from __future__ import annotations

"""Base generator infrastructure for BeautifulSoup RL environment.

This module provides the foundational classes and utilities for task generation:
- TaskInstance: The data structure representing a single task
- Generator: The protocol that all archetype generators must follow
- RNG utilities: Deterministic random number generation
- HTML noise helpers: Functions to add realistic noise to HTML
- HtmlStyle: Framework-specific HTML generation patterns
"""

import hashlib
import random
import re
import string
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Sequence


# =============================================================================
# HTML Style System - Framework-Specific Patterns
# =============================================================================


class HtmlStyle(Enum):
    """HTML generation styles matching real-world frameworks.

    Each style produces HTML with characteristic patterns that train models
    to handle the diversity of real-world websites.
    """

    TRADITIONAL = "traditional"  # Wikipedia, docs sites, semantic HTML
    BOOTSTRAP = "bootstrap"  # Bootstrap 4/5 grid, component classes
    TAILWIND = "tailwind"  # Utility-class explosion
    REACT_SPA = "react_spa"  # data-reactroot, hashed classes, hydration
    ANGULAR = "angular"  # ng-* attributes, _ngcontent-* scopes
    VUE = "vue"  # data-v-* attributes, v-* directives


@dataclass
class TaskInstance:
    """A single task instance generated by an archetype generator.

    Attributes:
        html: The HTML content to be parsed.
        query: Natural language description of what to extract.
        ground_truth: The expected correct answer (hidden from model).
        archetype_id: The archetype that generated this instance.
        seed: The seed used to generate this instance.
        solvable: Whether this task is solvable with BS4.
        answer_schema: JSON schema for the expected answer format.
        normalization: Rules for normalizing the answer before comparison.
        limit_info: For limitation tasks, the valid reasons and evidence patterns.
        safety_info: Forbidden patterns and fields to check for safety violations.
        metadata: Additional metadata for analysis and debugging.
    """

    html: str
    query: str
    ground_truth: Any
    archetype_id: str
    seed: int
    solvable: bool = True
    answer_schema: dict = field(default_factory=dict)
    normalization: dict = field(default_factory=lambda: {
        "strip_whitespace": True,
        "collapse_whitespace": True,
        "unicode_nfc": True,
        "sort_lists": False,
        "sort_dict_keys": True,
    })
    limit_info: dict = field(default_factory=lambda: {
        "allowed_reasons": [],
        "evidence_patterns": [],
    })
    safety_info: dict = field(default_factory=lambda: {
        "forbidden_patterns": [],
        "forbidden_fields": [],
    })
    metadata: dict = field(default_factory=dict)

    def to_info_dict(self) -> dict[str, Any]:
        """Convert to the info dict format used in dataset rows.

        Returns:
            Dictionary with all task information for grading.
        """
        return {
            "archetype_id": self.archetype_id,
            "seed": self.seed,
            "solvable": self.solvable,
            "ground_truth": self.ground_truth,
            "answer_schema": self.answer_schema,
            "normalization": self.normalization,
            "limit_info": self.limit_info,
            "safety_info": self.safety_info,
            "metadata": self.metadata,
            # HTML and query stored here since not in prompt
            "html": self.html,
            "query": self.query,
        }


class Generator(ABC):
    """Abstract base class for task generators.

    Each archetype implements this protocol to generate task instances.
    Generators must be deterministic: same seed -> same output.
    """

    # Set by @register decorator
    _archetype_spec: Any = None

    @property
    def archetype_id(self) -> str:
        """Get the archetype ID from the registered spec."""
        if self._archetype_spec is None:
            raise RuntimeError(
                f"{self.__class__.__name__} was not registered with @register"
            )
        return self._archetype_spec.archetype_id

    @abstractmethod
    def generate(self, seed: int) -> TaskInstance:
        """Generate a task instance from a seed.

        This method must be deterministic: the same seed must always
        produce the same task instance.

        Args:
            seed: Integer seed for reproducible generation.

        Returns:
            A TaskInstance with all required fields populated.
        """
        pass


def stable_int_seed(split: str, archetype_id: str, seed: int) -> int:
    """Generate a stable integer seed from split, archetype, and seed.

    Uses SHA-256 to combine inputs into a deterministic integer.
    This avoids Python's salted hash() which is not reproducible across runs.

    Args:
        split: The dataset split (train, eval, bench).
        archetype_id: The archetype identifier.
        seed: The base seed value.

    Returns:
        A stable integer seed suitable for random.Random().
    """
    data = f"{split}:{archetype_id}:{seed}".encode("utf-8")
    hash_bytes = hashlib.sha256(data).digest()
    # Use first 8 bytes as a 64-bit integer
    return int.from_bytes(hash_bytes[:8], byteorder="big")


def make_rng(archetype_id: str, seed: int, split: str = "train") -> random.Random:
    """Create a seeded random.Random instance for a task.

    Args:
        archetype_id: The archetype identifier.
        seed: The base seed value.
        split: The dataset split (default "train").

    Returns:
        A seeded random.Random instance.
    """
    stable_seed = stable_int_seed(split, archetype_id, seed)
    return random.Random(stable_seed)


# =============================================================================
# HTML Noise and Variation Helpers
# =============================================================================


def random_whitespace(rng: random.Random, min_len: int = 1, max_len: int = 3) -> str:
    """Generate random whitespace string.

    Args:
        rng: Random instance.
        min_len: Minimum length.
        max_len: Maximum length.

    Returns:
        String of random whitespace characters.
    """
    length = rng.randint(min_len, max_len)
    chars = [" ", "\t", "\n"]
    weights = [0.7, 0.2, 0.1]
    return "".join(rng.choices(chars, weights=weights, k=length))


def add_noise_comments(html: str, rng: random.Random, count: int = 3) -> str:
    """Add random HTML comments to the document.

    Args:
        html: The HTML string.
        rng: Random instance.
        count: Number of comments to add.

    Returns:
        HTML with added comments.
    """
    comments = [
        "<!-- TODO: fix this -->",
        "<!-- legacy code -->",
        "<!-- generated by cms -->",
        "<!-- analytics tag -->",
        "<!-- do not modify -->",
        "<!-- end section -->",
        "<!-- begin content -->",
        "<!-- version 2.1 -->",
    ]

    for _ in range(count):
        comment = rng.choice(comments)
        # Find a random position to insert (after a tag close)
        positions = [m.end() for m in re.finditer(r">", html)]
        if positions:
            pos = rng.choice(positions)
            html = html[:pos] + comment + html[pos:]

    return html


def randomize_attribute_order(tag: str, rng: random.Random) -> str:
    """Randomize the order of attributes in an HTML tag.

    Args:
        tag: An HTML tag string like '<div class="foo" id="bar">'.
        rng: Random instance.

    Returns:
        The tag with attributes in random order.
    """
    # Parse the tag
    match = re.match(r"<(\w+)((?:\s+[^>]*)?)\s*/?>", tag)
    if not match:
        return tag

    tag_name = match.group(1)
    attrs_str = match.group(2).strip()

    if not attrs_str:
        return tag

    # Extract attributes
    attr_pattern = r'(\w+)(?:=(?:"([^"]*)"|\'([^\']*)\'|(\S+)))?'
    attrs = re.findall(attr_pattern, attrs_str)

    if len(attrs) <= 1:
        return tag

    # Shuffle attributes
    rng.shuffle(attrs)

    # Reconstruct
    attr_strs = []
    for name, val_dq, val_sq, val_bare in attrs:
        if val_dq:
            attr_strs.append(f'{name}="{val_dq}"')
        elif val_sq:
            attr_strs.append(f"{name}='{val_sq}'")
        elif val_bare:
            attr_strs.append(f"{name}={val_bare}")
        else:
            attr_strs.append(name)

    is_self_closing = tag.rstrip().endswith("/>")
    closing = "/>" if is_self_closing else ">"
    return f"<{tag_name} {' '.join(attr_strs)}{closing}"


def add_decoy_elements(
    html: str,
    rng: random.Random,
    decoys: Sequence[str] | None = None,
    count: int = 2,
) -> str:
    """Add decoy elements that might distract naive extractors.

    Args:
        html: The HTML string.
        rng: Random instance.
        decoys: List of decoy HTML snippets. If None, uses defaults.
        count: Number of decoys to add.

    Returns:
        HTML with added decoy elements.
    """
    if decoys is None:
        decoys = [
            '<div class="hidden" style="display:none">decoy content</div>',
            '<span class="sr-only">screen reader only</span>',
            '<noscript>Enable JavaScript</noscript>',
            '<template id="tmpl">template content</template>',
            '<!-- <div class="old">deprecated</div> -->',
        ]

    for _ in range(count):
        decoy = rng.choice(decoys)
        # Insert before </body> if present, otherwise at end
        if "</body>" in html:
            html = html.replace("</body>", f"{decoy}</body>", 1)
        else:
            html += decoy

    return html


def random_class_name(rng: random.Random, prefix: str = "") -> str:
    """Generate a random CSS class name.

    Args:
        rng: Random instance.
        prefix: Optional prefix for the class name.

    Returns:
        A random class name string.
    """
    suffixes = ["container", "wrapper", "content", "item", "box", "section", "main"]
    modifiers = ["primary", "secondary", "active", "hidden", "new", "old", "v2"]

    parts = [prefix] if prefix else []
    parts.append(rng.choice(suffixes))
    if rng.random() < 0.5:
        parts.append(rng.choice(modifiers))
    if rng.random() < 0.3:
        parts.append(str(rng.randint(1, 99)))

    return "-".join(parts)


def random_id(rng: random.Random, prefix: str | None = None) -> str:
    """Generate a random HTML ID.

    By default, generates fully random IDs with no semantic prefix.
    This prevents models from shortcutting by pattern-matching on prefixes
    like "target-" vs "other-".

    Args:
        rng: Random instance.
        prefix: Optional prefix for the ID. If None (default), uses random base.

    Returns:
        A random ID string.
    """
    # Use fully random bases by default to avoid semantic prefixes
    bases = [
        "el", "node", "item", "block", "comp", "sect", "wrap", "unit",
        "elem", "box", "part", "seg", "zone", "area", "cell", "slot",
    ]
    base = prefix if prefix is not None else rng.choice(bases)
    suffix = "".join(rng.choices(string.ascii_lowercase + string.digits, k=8))
    return f"{base}-{suffix}"


def introduce_malformation(
    html: str,
    rng: random.Random,
    malformation_type: str | None = None,
) -> str:
    """Introduce a specific type of HTML malformation.

    Args:
        html: The HTML string.
        rng: Random instance.
        malformation_type: Type of malformation. If None, chooses randomly.
            Options: "unclosed_tag", "missing_quotes", "bad_nesting"

    Returns:
        Malformed HTML string.
    """
    if malformation_type is None:
        malformation_type = rng.choice(["unclosed_tag", "missing_quotes", "bad_nesting"])

    if malformation_type == "unclosed_tag":
        # Remove a closing tag
        closing_tags = list(re.finditer(r"</(\w+)>", html))
        if closing_tags:
            match = rng.choice(closing_tags)
            html = html[: match.start()] + html[match.end() :]

    elif malformation_type == "missing_quotes":
        # Remove quotes from an attribute value (if value has no spaces)
        attr_pattern = r'(\w+)="([^"\s]+)"'
        matches = list(re.finditer(attr_pattern, html))
        if matches:
            match = rng.choice(matches)
            replacement = f"{match.group(1)}={match.group(2)}"
            html = html[: match.start()] + replacement + html[match.end() :]

    elif malformation_type == "bad_nesting":
        # Create overlapping tags (e.g., <b><i>text</b></i>)
        # This is tricky to do safely, so we just add a known bad pattern
        bad_patterns = [
            "<b><i>overlapped</b></i>",
            "<p><div>block in inline</div></p>",
        ]
        pattern = rng.choice(bad_patterns)
        if "</body>" in html:
            html = html.replace("</body>", f"{pattern}</body>", 1)
        else:
            html += pattern

    return html


# =============================================================================
# Content Generation Helpers
# =============================================================================


def random_person_name(rng: random.Random) -> str:
    """Generate a random person name."""
    first_names = [
        "Alice", "Bob", "Carol", "David", "Emma", "Frank", "Grace", "Henry",
        "Ivy", "Jack", "Karen", "Leo", "Maria", "Nathan", "Olivia", "Peter",
    ]
    last_names = [
        "Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia", "Miller",
        "Davis", "Martinez", "Anderson", "Wilson", "Taylor", "Thomas", "Lee",
    ]
    return f"{rng.choice(first_names)} {rng.choice(last_names)}"


def random_company_name(rng: random.Random) -> str:
    """Generate a random company name."""
    prefixes = ["Acme", "Global", "Tech", "Prime", "Alpha", "Omega", "Nova", "Apex"]
    suffixes = ["Corp", "Inc", "LLC", "Solutions", "Systems", "Industries", "Labs"]
    return f"{rng.choice(prefixes)} {rng.choice(suffixes)}"


def random_product_name(rng: random.Random) -> str:
    """Generate a random product name."""
    adjectives = ["Super", "Ultra", "Pro", "Max", "Plus", "Elite", "Premium"]
    nouns = ["Widget", "Gadget", "Tool", "Device", "System", "Kit", "Set"]
    return f"{rng.choice(adjectives)} {rng.choice(nouns)}"


def random_price(rng: random.Random, min_val: float = 9.99, max_val: float = 999.99) -> str:
    """Generate a random price string."""
    value = rng.uniform(min_val, max_val)
    return f"${value:.2f}"


def random_date(rng: random.Random) -> str:
    """Generate a random date string in various formats."""
    year = rng.randint(2020, 2025)
    month = rng.randint(1, 12)
    day = rng.randint(1, 28)  # Safe for all months

    formats = [
        f"{year}-{month:02d}-{day:02d}",
        f"{month:02d}/{day:02d}/{year}",
        f"{day:02d}.{month:02d}.{year}",
    ]
    return rng.choice(formats)


def random_url(rng: random.Random, base: str = "https://example.com") -> str:
    """Generate a random URL."""
    paths = ["products", "about", "contact", "blog", "news", "help", "faq"]
    slugs = ["item", "page", "post", "article", "entry"]
    return f"{base}/{rng.choice(paths)}/{rng.choice(slugs)}-{rng.randint(1, 999)}"


def random_email(rng: random.Random) -> str:
    """Generate a random email address."""
    names = ["user", "contact", "info", "hello", "support", "admin"]
    domains = ["example.com", "test.org", "sample.net", "demo.io"]
    return f"{rng.choice(names)}{rng.randint(1, 999)}@{rng.choice(domains)}"


def random_paragraph(rng: random.Random, sentences: int = 3) -> str:
    """Generate a random paragraph of lorem ipsum-like text."""
    result = []
    for _ in range(sentences):
        result.append(generate_sentence(rng))
    return " ".join(result)


def generate_sentence(rng: random.Random) -> str:
    """Generate a single random sentence with varied length and structure.

    Returns sentences from short (5-8 words) to complex (20+ words).
    """
    template = rng.choice(SENTENCE_TEMPLATES)
    return template.format(
        adj=rng.choice(ADJECTIVES),
        adj2=rng.choice(ADJECTIVES),
        noun=rng.choice(NOUNS),
        noun2=rng.choice(NOUNS),
        verb=rng.choice(VERBS),
        verb2=rng.choice(VERBS),
    )


def generate_variable_content(
    rng: random.Random,
    min_sentences: int = 1,
    max_sentences: int = 10,
) -> str:
    """Generate content with variable sentence count for unpredictable lengths.

    Real content varies widely - some elements have one sentence, others have
    paragraphs. This prevents models from learning length patterns.

    Args:
        rng: Random instance.
        min_sentences: Minimum sentences (default 1).
        max_sentences: Maximum sentences (default 10).

    Returns:
        Content string with random number of sentences.
    """
    sentence_count = rng.randint(min_sentences, max_sentences)
    return " ".join(generate_sentence(rng) for _ in range(sentence_count))


# =============================================================================
# Semantic Decoy Generation
# =============================================================================


def generate_semantic_decoy(
    rng: random.Random,
    target_text: str,
    variation_type: str | None = None,
) -> str:
    """Generate content that's semantically similar to the target.

    This creates harder decoys that can't be distinguished by simple
    pattern matching - they have similar structure and vocabulary but
    different specific content.

    Args:
        rng: Random instance.
        target_text: The target content to create a variation of.
        variation_type: Type of variation. If None, randomly selected.
            Options: "paraphrase", "similar_topic", "partial_overlap"

    Returns:
        Semantically similar but different content.
    """
    if variation_type is None:
        variation_type = rng.choice(["paraphrase", "similar_topic", "partial_overlap"])

    sentences = target_text.split(". ")
    num_sentences = len(sentences)

    if variation_type == "paraphrase":
        # Keep similar structure but swap vocabulary
        result = []
        for _ in range(num_sentences):
            result.append(generate_sentence(rng))
        return " ".join(result)

    elif variation_type == "similar_topic":
        # Generate content with the same approximate length and tone
        word_count = len(target_text.split())
        target_sentences = max(1, word_count // 12)  # ~12 words per sentence
        return " ".join(generate_sentence(rng) for _ in range(target_sentences))

    elif variation_type == "partial_overlap":
        # Use some of the target text mixed with new content
        if num_sentences >= 2:
            # Keep first sentence, generate rest
            kept = sentences[0]
            new_content = " ".join(generate_sentence(rng) for _ in range(num_sentences - 1))
            return f"{kept}. {new_content}"
        else:
            return generate_sentence(rng)

    return generate_variable_content(rng, min_sentences=1, max_sentences=3)


def generate_near_duplicate(
    rng: random.Random,
    target_text: str,
    mutation_type: str | None = None,
) -> str:
    """Generate content that's almost identical to target with subtle differences.

    Creates decoys that are hard to distinguish from the target without
    careful reading - tests whether the model is actually extracting the
    right element vs. guessing based on similarity.

    Args:
        rng: Random instance.
        target_text: The target content to mutate.
        mutation_type: Type of mutation. If None, randomly selected.
            Options: "truncate", "append", "swap_words", "add_qualifier"

    Returns:
        Near-duplicate content that's subtly different.
    """
    if mutation_type is None:
        mutation_type = rng.choice(["truncate", "append", "swap_words", "add_qualifier"])

    if mutation_type == "truncate":
        # Cut off at a natural boundary
        sentences = target_text.split(". ")
        if len(sentences) > 1:
            cut_point = rng.randint(1, len(sentences) - 1)
            return ". ".join(sentences[:cut_point]) + "..."
        else:
            # Cut mid-sentence
            words = target_text.split()
            if len(words) > 5:
                cut_point = rng.randint(len(words) // 2, len(words) - 2)
                return " ".join(words[:cut_point]) + "..."
        return target_text[:len(target_text) // 2] + "..."

    elif mutation_type == "append":
        # Add extra content at the end
        suffixes = [
            " (continued on next page)",
            " Read more below.",
            " See related content.",
            " Additional details available.",
            " [Last updated: 2024]",
            " (Source: internal data)",
        ]
        return target_text + rng.choice(suffixes)

    elif mutation_type == "swap_words":
        # Replace a few words with synonyms or similar words
        words = target_text.split()
        if len(words) > 5:
            # Swap 1-2 words
            num_swaps = rng.randint(1, min(2, len(words) // 3))
            for _ in range(num_swaps):
                idx = rng.randint(0, len(words) - 1)
                # Replace with a random word of similar length
                original = words[idx]
                if len(original) > 3:
                    replacement = rng.choice(["similar", "related", "relevant", "comparable", "corresponding", "associated"])
                    words[idx] = replacement
            return " ".join(words)
        return target_text

    elif mutation_type == "add_qualifier":
        # Add qualifiers that change meaning slightly
        qualifiers = [
            ("", " (preliminary data)"),
            ("", " (subject to change)"),
            ("", " (estimated)"),
            ("Note: ", ""),
            ("Important: ", ""),
            ("Updated: ", ""),
        ]
        prefix, suffix = rng.choice(qualifiers)
        return prefix + target_text + suffix

    return target_text


def generate_similar_id(
    rng: random.Random,
    target_id: str,
    similarity_type: str | None = None,
) -> str:
    """Generate an ID that looks similar to the target ID.

    Creates decoy IDs that could be confused with the target,
    testing whether the model is reading IDs carefully.

    Args:
        rng: Random instance.
        target_id: The target ID to create a variant of.
        similarity_type: Type of similarity. If None, randomly selected.
            Options: "suffix_change", "prefix_change", "typo", "numeric_similar"

    Returns:
        Similar but different ID.
    """
    if similarity_type is None:
        similarity_type = rng.choice(["suffix_change", "prefix_change", "typo", "numeric_similar"])

    if similarity_type == "suffix_change":
        # Change last few characters
        if len(target_id) > 4:
            base = target_id[:-3]
            new_suffix = "".join(rng.choices(string.ascii_lowercase + string.digits, k=3))
            return base + new_suffix
        return target_id + str(rng.randint(1, 99))

    elif similarity_type == "prefix_change":
        # Change first few characters
        if len(target_id) > 4:
            suffix = target_id[3:]
            new_prefix = "".join(rng.choices(string.ascii_lowercase, k=3))
            return new_prefix + suffix
        return "x" + target_id[1:] if target_id else random_id(rng)

    elif similarity_type == "typo":
        # Introduce a single character change
        if len(target_id) > 2:
            idx = rng.randint(1, len(target_id) - 2)
            char_list = list(target_id)
            # Replace with a similar-looking character
            similar = {
                'a': 'e', 'e': 'a', 'i': 'l', 'l': 'i', 'o': '0', '0': 'o',
                '1': 'l', 'm': 'n', 'n': 'm', 'p': 'q', 'q': 'p', 'u': 'v',
                'v': 'u', 'b': 'd', 'd': 'b', 's': '5', '5': 's',
            }
            old_char = char_list[idx]
            char_list[idx] = similar.get(old_char, rng.choice(string.ascii_lowercase))
            return "".join(char_list)
        return target_id + "x"

    elif similarity_type == "numeric_similar":
        # If ID has numbers, change them slightly
        result = []
        for char in target_id:
            if char.isdigit():
                # Change to adjacent number
                num = int(char)
                new_num = (num + rng.choice([-1, 1])) % 10
                result.append(str(new_num))
            else:
                result.append(char)
        new_id = "".join(result)
        return new_id if new_id != target_id else target_id + "2"

    return random_id(rng)


def generate_similar_class(
    rng: random.Random,
    target_class: str,
) -> str:
    """Generate a class name that looks similar to the target.

    Args:
        rng: Random instance.
        target_class: The target class to create a variant of.

    Returns:
        Similar but different class name.
    """
    # Use similar generation logic to IDs
    similarity_type = rng.choice(["suffix_change", "prefix_change", "modifier"])

    if similarity_type == "suffix_change":
        parts = target_class.rsplit("-", 1)
        if len(parts) == 2:
            return f"{parts[0]}-{rng.choice(['alt', 'v2', 'new', 'old', 'temp'])}"
        return target_class + "-alt"

    elif similarity_type == "prefix_change":
        parts = target_class.split("-", 1)
        if len(parts) == 2:
            prefixes = ["main", "sub", "alt", "sec", "pri"]
            return f"{rng.choice(prefixes)}-{parts[1]}"
        return "alt-" + target_class

    elif similarity_type == "modifier":
        modifiers = ["primary", "secondary", "active", "hidden", "new", "legacy"]
        return f"{target_class}-{rng.choice(modifiers)}"

    return random_class_name(rng)


# =============================================================================
# Expanded Vocabularies (10x the original 8 items each)
# =============================================================================

# 80+ adjectives organized by category
ADJECTIVES = [
    # Physical properties
    "quick", "slow", "lazy", "energetic", "bright", "dark", "dim", "radiant",
    "small", "large", "tiny", "massive", "heavy", "light", "dense", "hollow",
    "old", "new", "ancient", "modern", "vintage", "contemporary", "antique", "fresh",
    "warm", "cold", "hot", "cool", "frozen", "tepid", "scorching", "chilly",
    "soft", "hard", "firm", "flexible", "rigid", "elastic", "brittle", "supple",
    # Texture and appearance
    "rough", "smooth", "bumpy", "sleek", "glossy", "matte", "shiny", "dull",
    "clean", "dirty", "pristine", "grimy", "spotless", "dusty", "polished", "tarnished",
    # Size and shape
    "narrow", "wide", "thin", "thick", "tall", "short", "round", "square",
    "deep", "shallow", "long", "brief", "curved", "straight", "angular", "circular",
    # Quality and state
    "simple", "complex", "plain", "ornate", "basic", "elaborate", "minimal", "intricate",
    "quiet", "loud", "silent", "noisy", "peaceful", "chaotic", "calm", "turbulent",
]

# 80+ nouns organized by category
NOUNS = [
    # Animals
    "fox", "dog", "cat", "bird", "wolf", "bear", "deer", "rabbit",
    "eagle", "owl", "hawk", "sparrow", "dolphin", "whale", "shark", "octopus",
    "lion", "tiger", "elephant", "giraffe", "zebra", "horse", "cow", "sheep",
    # Nature
    "tree", "river", "mountain", "valley", "forest", "meadow", "ocean", "desert",
    "garden", "flower", "leaf", "branch", "rock", "stone", "pebble", "boulder",
    "cloud", "rain", "snow", "wind", "storm", "thunder", "lightning", "rainbow",
    # Buildings and structures
    "house", "tower", "bridge", "castle", "cabin", "barn", "church", "temple",
    "window", "door", "gate", "wall", "roof", "floor", "ceiling", "staircase",
    # Objects
    "car", "book", "table", "chair", "lamp", "clock", "mirror", "carpet",
    "phone", "computer", "camera", "bicycle", "airplane", "ship", "train", "bus",
    "cup", "plate", "bowl", "knife", "spoon", "fork", "bottle", "jar",
    "pen", "paper", "envelope", "stamp", "key", "lock", "box", "bag",
]

# 64+ verbs organized by category
VERBS = [
    # Movement
    "jumped", "ran", "walked", "flew", "crawled", "climbed", "fell", "rolled",
    "sprinted", "strolled", "marched", "dashed", "glided", "soared", "plunged", "leaped",
    "spun", "twirled", "rotated", "swayed", "bounced", "slid", "tumbled", "wandered",
    # Position changes
    "sat", "stood", "lay", "knelt", "crouched", "leaned", "bent", "stretched",
    "rose", "dropped", "lifted", "lowered", "raised", "sank", "floated", "hovered",
    # State changes
    "appeared", "vanished", "emerged", "faded", "grew", "shrank", "expanded", "contracted",
    "opened", "closed", "folded", "unfolded", "wrapped", "unwrapped", "locked", "unlocked",
    # Actions
    "moved", "rested", "waited", "watched", "listened", "spoke", "whispered", "shouted",
    "searched", "found", "lost", "discovered", "created", "destroyed", "built", "demolished",
]

# 30+ sentence templates with variable lengths (short/medium/long/complex)
SENTENCE_TEMPLATES = [
    # Short forms (5-8 words)
    "The {adj} {noun} {verb}.",
    "A {noun} {verb} nearby.",
    "{noun}s often {verb} here.",
    "The {noun} seemed {adj}.",
    "Something {adj} {verb} quietly.",
    "The {noun} was {adj}.",

    # Medium forms (8-12 words)
    "The {adj} {noun} {verb} the {noun2}.",
    "A {noun} was {verb} by the {adj} {noun2}.",
    "Several {adj} {noun}s {verb} near the {noun2}.",
    "The {noun} appeared to be {adj} and {verb}.",
    "When the {noun} {verb}, the {adj} {noun2} remained still.",
    "Despite being {adj}, the {noun} {verb} towards the {noun2}.",
    "The {adj} {noun} slowly {verb} across the room.",
    "Near the {noun}, a {adj} {noun2} {verb} softly.",

    # Long forms (12-20 words)
    "The {noun2} watched as the {adj} {noun} {verb} slowly across the floor.",
    "Neither the {noun} nor the {noun2} had {verb} before that moment.",
    "Only the {adj} {noun} knew why the {noun2} had {verb} so suddenly.",
    "Before the {noun} {verb}, everything in the room seemed perfectly {adj}.",
    "After the {adj} {noun2} {verb}, silence filled the room completely.",
    "Between the {noun} and the {noun2}, something {adj} began to stir.",
    "The {adj} {noun} {verb} while the {noun2} continued to watch carefully.",
    "Without warning, the {noun} {verb} and startled the nearby {noun2}.",

    # Complex forms (20+ words)
    "In the {adj} corner of the room, a {noun} {verb} while the {noun2} watched with interest.",
    "The {noun} had never {verb} like this before, and the {adj} {noun2} took notice immediately.",
    "Although the {noun} tried to remain {adj}, it eventually {verb} when the {noun2} approached.",
    "No one expected the {adj} {noun} to {verb2}, but when it did, the {noun2} reacted instantly.",
    "Throughout the {adj} afternoon, the {noun} {verb} repeatedly near the {noun2}.",
    "The {noun2} wondered why the {adj} {noun} had {verb} without any warning.",
    "From across the {adj} field, a {noun} could be seen as it {verb} towards the {noun2}.",
    "Despite the {adj} weather, the {noun} continued to {verb2} near the waiting {noun2}.",
    "As the {noun} {verb}, the {adj} {noun2} prepared to respond in kind.",
    "The {adj} {noun} {verb} three times before the startled {noun2} could react.",
    "Under the {adj} sky, the {noun} and the {noun2} both {verb} at the same moment.",
    "It was unusual for a {noun} to {verb} so close to where the {adj} {noun2} rested.",
    "The {noun2} had always been {adj}, but today it {verb} with unexpected grace.",
    "When the {adj} {noun} finally {verb}, everyone near the {noun2} fell silent.",
]


# =============================================================================
# Framework-Specific Class Name Generators
# =============================================================================


def random_traditional_class(rng: random.Random) -> str:
    """Generate traditional semantic class names (Wikipedia, docs style)."""
    prefixes = ["", "mw-", "wiki-", "doc-", "content-", "page-"]
    words = [
        "content", "wrapper", "container", "section", "article", "sidebar",
        "navigation", "header", "footer", "main", "body", "text", "parser-output",
    ]
    modifiers = ["", "-inner", "-outer", "-left", "-right", "-primary", "-secondary"]

    return f"{rng.choice(prefixes)}{rng.choice(words)}{rng.choice(modifiers)}"


# =============================================================================
# Realistic Patterns from Mind2Web Analysis
# =============================================================================

# State/visibility classes observed in real websites
STATE_CLASSES = [
    # Visibility
    "hide", "hidden", "show", "visible", "invisible",
    "visually-hidden", "sr-only", "d-none", "d-block",
    # State
    "active", "inactive", "disabled", "enabled",
    "selected", "unselected", "checked", "unchecked",
    "collapsed", "expanded", "open", "closed",
    "authenticated", "unauthenticated", "logged-in", "logged-out",
    # Loading
    "loading", "loaded", "pending", "complete",
    # Validation
    "valid", "invalid", "error", "success", "warning",
    # Angular-specific state
    "ng-pristine", "ng-valid", "ng-invalid", "ng-touched", "ng-dirty",
]


def random_branded_prefix(rng: random.Random) -> str:
    """Generate company-branded class prefixes like real sites use.

    Examples from Mind2Web:
    - Tesla: tds-* (tds-link, tds-banner, tds--product-name)
    - Uniqlo: fr-ec-*, uq-ec-* (fr-ec-button-reset, uq-ec-link-primary-nav)
    - JetBlue: jb* (jbSurvey)

    Args:
        rng: Random instance.

    Returns:
        Branded prefix string like "acme-" or "corp--".
    """
    # Company-like prefixes
    companies = [
        "acme", "app", "site", "brand", "corp", "ui", "core", "base",
        "web", "my", "pro", "ec", "shop", "biz", "tech", "data",
    ]
    # Different separator styles
    separators = ["-", "--", "_", ""]

    company = rng.choice(companies)
    sep = rng.choice(separators)

    return f"{company}{sep}"


def random_branded_class(rng: random.Random) -> str:
    """Generate a full branded class name.

    Args:
        rng: Random instance.

    Returns:
        Full class name like "acme-container" or "corp--button-primary".
    """
    prefix = random_branded_prefix(rng)
    words = [
        "container", "wrapper", "item", "link", "button", "nav", "header",
        "footer", "content", "card", "list", "menu", "panel", "modal",
        "form", "input", "label", "text", "icon", "image", "badge",
    ]
    modifiers = ["", "-primary", "-secondary", "-active", "-disabled", "-lg", "-sm"]

    return f"{prefix}{rng.choice(words)}{rng.choice(modifiers)}"


def random_state_class(rng: random.Random) -> str:
    """Get a random state/visibility class.

    Args:
        rng: Random instance.

    Returns:
        State class like "active" or "collapsed".
    """
    return rng.choice(STATE_CLASSES)


def random_bootstrap_classes(rng: random.Random, count: int = 3) -> str:
    """Generate Bootstrap-style utility and component classes."""
    grid_classes = [
        "container", "container-fluid", "row", "col", "col-sm-6", "col-md-4",
        "col-lg-3", "col-xl-2", "col-12", "col-auto", "g-3", "g-4", "gy-4", "gx-3",
    ]
    spacing = [
        "p-0", "p-1", "p-2", "p-3", "p-4", "p-5", "m-0", "m-1", "m-2", "m-3",
        "mt-3", "mb-4", "ms-2", "me-2", "mx-auto", "my-3", "px-4", "py-2",
    ]
    display = [
        "d-none", "d-block", "d-flex", "d-inline", "d-inline-block", "d-grid",
    ]
    flex = [
        "flex-row", "flex-column", "justify-content-center", "justify-content-between",
        "align-items-center", "align-items-start", "flex-wrap", "flex-nowrap",
    ]
    components = [
        "card", "card-body", "card-header", "card-footer", "btn", "btn-primary",
        "btn-secondary", "btn-outline-primary", "navbar", "nav-item", "nav-link",
        "list-group", "list-group-item", "badge", "alert", "alert-info",
    ]
    text = [
        "text-center", "text-start", "text-end", "text-muted", "text-primary",
        "fw-bold", "fw-light", "fs-4", "fs-5", "lh-sm", "lh-lg",
    ]

    all_classes = grid_classes + spacing + display + flex + components + text
    return " ".join(rng.sample(all_classes, min(count, len(all_classes))))


def random_tailwind_classes(rng: random.Random, count: int = 8) -> str:
    """Generate Tailwind CSS utility class explosion."""
    layout = [
        "flex", "inline-flex", "grid", "block", "inline-block", "hidden",
        "flex-col", "flex-row", "flex-wrap", "flex-nowrap",
    ]
    spacing = [
        "p-0", "p-1", "p-2", "p-3", "p-4", "p-6", "p-8", "px-4", "py-2", "py-6",
        "m-0", "m-1", "m-2", "m-4", "mx-auto", "my-4", "mt-2", "mb-4", "ml-2", "mr-2",
        "space-x-2", "space-x-4", "space-y-2", "space-y-4", "gap-2", "gap-4",
    ]
    sizing = [
        "w-full", "w-1/2", "w-1/3", "w-1/4", "w-auto", "w-screen", "w-64", "w-96",
        "h-full", "h-auto", "h-screen", "h-12", "h-16", "h-24", "min-h-screen",
        "max-w-md", "max-w-lg", "max-w-xl", "max-w-2xl", "max-w-7xl",
    ]
    colors = [
        "bg-white", "bg-gray-50", "bg-gray-100", "bg-gray-200", "bg-blue-500",
        "bg-indigo-600", "bg-green-500", "bg-red-500", "bg-yellow-400",
        "text-gray-500", "text-gray-700", "text-gray-900", "text-white",
        "text-blue-600", "text-indigo-600", "border-gray-200", "border-gray-300",
    ]
    typography = [
        "text-xs", "text-sm", "text-base", "text-lg", "text-xl", "text-2xl",
        "font-normal", "font-medium", "font-semibold", "font-bold",
        "leading-tight", "leading-relaxed", "tracking-tight", "tracking-wide",
    ]
    effects = [
        "rounded", "rounded-md", "rounded-lg", "rounded-full", "rounded-none",
        "shadow", "shadow-sm", "shadow-md", "shadow-lg", "shadow-xl",
        "opacity-50", "opacity-75", "opacity-100",
    ]
    borders = [
        "border", "border-0", "border-2", "border-t", "border-b", "border-l", "border-r",
    ]
    interactivity = [
        "cursor-pointer", "cursor-default", "hover:bg-gray-100", "hover:text-blue-600",
        "focus:outline-none", "focus:ring-2", "focus:ring-blue-500",
        "transition", "transition-all", "duration-150", "duration-300",
    ]
    alignment = [
        "items-center", "items-start", "items-end", "justify-center",
        "justify-between", "justify-start", "justify-end", "self-center",
    ]

    all_classes = (
        layout + spacing + sizing + colors + typography +
        effects + borders + interactivity + alignment
    )
    return " ".join(rng.sample(all_classes, min(count, len(all_classes))))


def random_react_class(rng: random.Random) -> str:
    """Generate React/CSS Modules style hashed class names."""
    # CSS Modules pattern: ComponentName_className__hash
    components = [
        "Button", "Card", "Header", "Footer", "Sidebar", "Modal", "Input",
        "Form", "List", "Item", "Container", "Wrapper", "Content", "Title",
    ]
    class_names = [
        "root", "container", "wrapper", "inner", "content", "header",
        "body", "footer", "item", "active", "disabled", "primary",
    ]
    # Generate hash-like suffix
    hash_chars = string.ascii_lowercase + string.digits
    hash_suffix = "".join(rng.choices(hash_chars, k=5))

    component = rng.choice(components)
    class_name = rng.choice(class_names)

    # 50% chance of CSS Modules format, 50% chance of styled-components
    if rng.random() < 0.5:
        return f"{component}_{class_name}__{hash_suffix}"
    else:
        # styled-components format: sc-hash
        return f"sc-{hash_suffix}"


def random_angular_class(rng: random.Random) -> str:
    """Generate Angular-style class names with scoped attributes."""
    material_classes = [
        "mat-button", "mat-raised-button", "mat-card", "mat-card-content",
        "mat-form-field", "mat-input", "mat-select", "mat-option",
        "mat-list", "mat-list-item", "mat-toolbar", "mat-sidenav",
        "mat-icon", "mat-checkbox", "mat-radio-button", "mat-slide-toggle",
    ]
    ng_classes = [
        "ng-star-inserted", "ng-trigger", "ng-animating", "ng-valid",
        "ng-invalid", "ng-pristine", "ng-dirty", "ng-touched", "ng-untouched",
    ]

    if rng.random() < 0.6:
        return rng.choice(material_classes)
    else:
        return rng.choice(ng_classes)


def random_vue_class(rng: random.Random) -> str:
    """Generate Vue-style class names."""
    vue_classes = [
        "v-enter-active", "v-leave-active", "v-enter-from", "v-leave-to",
        "v-move", "fade-enter-active", "fade-leave-active", "slide-fade-enter",
    ]
    component_classes = [
        "vue-component", "v-btn", "v-card", "v-list", "v-list-item",
        "v-container", "v-row", "v-col", "v-app-bar", "v-navigation-drawer",
    ]

    all_classes = vue_classes + component_classes
    return rng.choice(all_classes)


def random_class_for_style(
    rng: random.Random,
    style: HtmlStyle,
    count: int | None = None,
) -> str:
    """Generate class name(s) appropriate for the given HTML style.

    Args:
        rng: Random instance.
        style: The HTML style to generate classes for.
        count: Number of classes (for styles that support multiple).

    Returns:
        Space-separated class names.
    """
    if style == HtmlStyle.TRADITIONAL:
        return random_traditional_class(rng)
    elif style == HtmlStyle.BOOTSTRAP:
        return random_bootstrap_classes(rng, count or 4)
    elif style == HtmlStyle.TAILWIND:
        return random_tailwind_classes(rng, count or 10)
    elif style == HtmlStyle.REACT_SPA:
        # React often has 1-2 classes per element
        classes = [random_react_class(rng) for _ in range(count or 2)]
        return " ".join(classes)
    elif style == HtmlStyle.ANGULAR:
        classes = [random_angular_class(rng) for _ in range(count or 2)]
        return " ".join(classes)
    elif style == HtmlStyle.VUE:
        return random_vue_class(rng)
    else:
        return random_class_name(rng)


def random_data_attributes(rng: random.Random, style: HtmlStyle) -> dict[str, str]:
    """Generate framework-specific data attributes.

    Args:
        rng: Random instance.
        style: The HTML style.

    Returns:
        Dictionary of attribute name -> value pairs.
    """
    attrs = {}
    hash_chars = string.ascii_lowercase + string.digits

    if style == HtmlStyle.REACT_SPA:
        if rng.random() < 0.3:
            attrs["data-reactroot"] = ""
        if rng.random() < 0.4:
            attrs["data-testid"] = f"test-{''.join(rng.choices(hash_chars, k=6))}"

    elif style == HtmlStyle.ANGULAR:
        scope_hash = "".join(rng.choices(hash_chars, k=8))
        attrs[f"_ngcontent-ng-c{rng.randint(100, 999)}"] = ""
        if rng.random() < 0.3:
            attrs["ng-reflect-ng-class"] = rng.choice(["active", "disabled", "primary"])

    elif style == HtmlStyle.VUE:
        vue_hash = "".join(rng.choices(hash_chars, k=7))
        attrs[f"data-v-{vue_hash}"] = ""

    # Common modern attributes
    if rng.random() < 0.2:
        roles = ["main", "navigation", "banner", "contentinfo", "article", "region"]
        attrs["role"] = rng.choice(roles)
    if rng.random() < 0.15:
        attrs["aria-label"] = rng.choice(["Main content", "Navigation", "Close", "Menu"])

    return attrs


# =============================================================================
# Mixed Framework and Repeated Element Generators
# =============================================================================


def generate_mixed_framework_classes(
    rng: random.Random,
    primary_style: HtmlStyle,
    count: int = 3,
) -> str:
    """Generate classes that mix framework patterns like real sites.

    Real sites often have:
    - Bootstrap layout with React components inside
    - Angular app with Bootstrap CSS utilities
    - Styled-components hashes mixed with semantic classes

    Args:
        rng: Random instance.
        primary_style: The primary framework style.
        count: Base number of classes.

    Returns:
        Space-separated class string mixing patterns.
    """
    classes = []

    # Primary framework classes
    primary = random_class_for_style(rng, primary_style, count=count)
    classes.append(primary)

    # 30% chance: Add styled-components/CSS modules hash
    if rng.random() < 0.3:
        classes.append(random_react_class(rng))

    # 25% chance: Add state class
    if rng.random() < 0.25:
        classes.append(random_state_class(rng))

    # 20% chance: Add branded prefix class
    if rng.random() < 0.2:
        classes.append(random_branded_class(rng))

    # 15% chance: Add JSX/Emotion hash (like jsx-3292870850)
    if rng.random() < 0.15:
        hash_num = rng.randint(1000000000, 9999999999)
        classes.append(f"jsx-{hash_num}")

    # 10% chance: Add CSS-in-JS pattern (like css-19jssuo-ComponentName)
    if rng.random() < 0.1:
        hash_chars = string.ascii_lowercase + string.digits
        hash_str = "".join(rng.choices(hash_chars, k=6))
        component = rng.choice(["Container", "Wrapper", "Item", "Button", "Card"])
        classes.append(f"css-{hash_str}-{component}")

    return " ".join(classes)


def generate_mixed_framework_element(
    rng: random.Random,
    primary_style: HtmlStyle,
    content: str,
    tag: str = "div",
) -> str:
    """Generate an element with mixed framework classes.

    Args:
        rng: Random instance.
        primary_style: The primary framework style.
        content: Inner HTML content.
        tag: HTML tag to use.

    Returns:
        HTML element string.
    """
    classes = generate_mixed_framework_classes(rng, primary_style)
    data_attrs = format_attributes(random_data_attributes(rng, primary_style))
    return f'<{tag} class="{classes}"{data_attrs}>{content}</{tag}>'


def generate_repeated_elements(
    rng: random.Random,
    style: HtmlStyle,
    count: int = 20,
    element_type: str = "li",
    wrapper_tag: str | None = None,
    wrapper_class: str | None = None,
) -> str:
    """Generate many elements with the same class repeated.

    Real sites have high class repetition:
    - Mind2Web: dropdown-link appeared 56 times
    - Mind2Web: col-xs-4 appeared 49 times
    - Mind2Web: ng-star-inserted appeared 26 times

    This trains models to handle long lists of similar elements.

    Args:
        rng: Random instance.
        style: The HTML style.
        count: Number of elements to generate.
        element_type: HTML tag for each element.
        wrapper_tag: Optional wrapper tag (e.g., "ul", "div").
        wrapper_class: Optional class for wrapper.

    Returns:
        HTML string with repeated elements.
    """
    # Pick a class that will repeat across all elements
    repeated_class = random_class_for_style(rng, style, count=1)

    # Sometimes add a state class that varies
    add_state = rng.random() < 0.3

    elements = []
    for i in range(count):
        # Same base class for all
        classes = [repeated_class]

        # Vary state on some elements
        if add_state and i == rng.randint(0, count - 1):
            classes.append(random_state_class(rng))

        class_str = " ".join(classes)

        # Generate varied content
        if element_type == "li":
            content = f"Item {i + 1}"
        elif element_type == "option":
            content = f"Option {i + 1}"
        else:
            content = random_paragraph(rng, sentences=1).split('.')[0]

        elements.append(f'<{element_type} class="{class_str}">{content}</{element_type}>')

    result = "\n".join(elements)

    if wrapper_tag:
        wrapper_cls = f' class="{wrapper_class}"' if wrapper_class else ""
        result = f"<{wrapper_tag}{wrapper_cls}>\n{result}\n</{wrapper_tag}>"

    return result


def generate_repeated_navigation(rng: random.Random, style: HtmlStyle, count: int = 25) -> str:
    """Generate a long navigation list with repeated classes.

    Real navigation menus have 20-50 items with the same class structure.

    Args:
        rng: Random instance.
        style: The HTML style.
        count: Number of nav items.

    Returns:
        HTML string for navigation.
    """
    nav_class = random_class_for_style(rng, style, count=2)
    item_class = random_class_for_style(rng, style, count=1)
    link_class = random_class_for_style(rng, style, count=1)

    # Add branded class to nav
    if rng.random() < 0.3:
        nav_class += " " + random_branded_class(rng)

    pages = [
        "Home", "About", "Products", "Services", "Blog", "News", "Contact",
        "FAQ", "Support", "Pricing", "Features", "Team", "Careers", "Press",
        "Partners", "Investors", "Legal", "Privacy", "Terms", "Help",
        "Documentation", "API", "Status", "Community", "Forums", "Events",
        "Webinars", "Resources", "Downloads", "Updates", "Changelog",
    ]

    items = []
    selected_pages = rng.sample(pages, min(count, len(pages)))

    for i, page in enumerate(selected_pages):
        # First item often has "active" state
        state = " active" if i == 0 and rng.random() < 0.5 else ""
        items.append(
            f'<li class="{item_class}{state}">'
            f'<a href="/{page.lower().replace(" ", "-")}" class="{link_class}">{page}</a>'
            f'</li>'
        )

    return f'<nav class="{nav_class}"><ul>\n{"".join(items)}\n</ul></nav>'


def format_attributes(attrs: dict[str, str]) -> str:
    """Format a dictionary of attributes as HTML attribute string.

    Args:
        attrs: Dictionary of attribute name -> value.

    Returns:
        Formatted attribute string (with leading space if non-empty).
    """
    if not attrs:
        return ""

    parts = []
    for name, value in attrs.items():
        if value == "":
            parts.append(name)
        else:
            parts.append(f'{name}="{value}"')

    return " " + " ".join(parts) if parts else ""


# =============================================================================
# HTML Document Chrome (Head, Scripts, Meta Tags)
# =============================================================================


def generate_head_content(
    rng: random.Random,
    style: HtmlStyle,
    title: str = "Page Title",
    complexity: str = "medium",
) -> str:
    """Generate realistic <head> content based on style and complexity.

    Args:
        rng: Random instance.
        style: The HTML style.
        title: Page title.
        complexity: "low", "medium", or "high".

    Returns:
        HTML string for head content (without <head> tags).
    """
    parts = [
        '<meta charset="utf-8">',
        f"<title>{title}</title>",
    ]

    # Basic meta tags (all complexity levels)
    parts.append('<meta name="viewport" content="width=device-width, initial-scale=1.0">')

    if complexity in ("medium", "high"):
        description = rng.choice([
            "Welcome to our website with great content.",
            "Find the best products and services here.",
            "Your source for quality information.",
            "Discover amazing content on our platform.",
        ])
        parts.append(f'<meta name="description" content="{description}">')
        parts.append('<meta name="robots" content="index, follow">')

    if complexity == "high":
        # Open Graph tags
        parts.extend([
            f'<meta property="og:title" content="{title}">',
            '<meta property="og:type" content="website">',
            '<meta property="og:url" content="https://example.com/page">',
            '<meta property="og:image" content="https://example.com/image.jpg">',
            # Twitter cards
            '<meta name="twitter:card" content="summary_large_image">',
            f'<meta name="twitter:title" content="{title}">',
        ])

    # Style-specific assets
    if style == HtmlStyle.TRADITIONAL:
        parts.append('<link rel="stylesheet" href="/static/styles.css">')

    elif style == HtmlStyle.BOOTSTRAP:
        parts.extend([
            '<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">',
        ])
        if complexity in ("medium", "high"):
            parts.append('<link rel="stylesheet" href="/static/custom.css">')

    elif style == HtmlStyle.TAILWIND:
        parts.append('<script src="https://cdn.tailwindcss.com"></script>')

    elif style == HtmlStyle.REACT_SPA:
        parts.extend([
            '<link rel="stylesheet" href="/static/main.css">',
            '<script defer src="/static/bundle.js"></script>',
        ])

    elif style == HtmlStyle.ANGULAR:
        parts.extend([
            '<link rel="stylesheet" href="styles.css">',
            '<script src="runtime.js" defer></script>',
            '<script src="polyfills.js" defer></script>',
            '<script src="main.js" defer></script>',
        ])

    elif style == HtmlStyle.VUE:
        parts.extend([
            '<link rel="stylesheet" href="/css/app.css">',
            '<script type="module" src="/js/app.js"></script>',
        ])

    # Favicon
    if complexity in ("medium", "high"):
        parts.append('<link rel="icon" href="/favicon.ico">')

    # Analytics (high complexity only)
    if complexity == "high":
        analytics_snippet = '''<script async src="https://www.googletagmanager.com/gtag/js?id=GA_MEASUREMENT_ID"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'GA_MEASUREMENT_ID');
</script>'''
        parts.append(analytics_snippet)

    return "\n    ".join(parts)


def generate_navigation(rng: random.Random, style: HtmlStyle) -> str:
    """Generate style-appropriate navigation markup.

    Args:
        rng: Random instance.
        style: The HTML style.

    Returns:
        HTML string for navigation.
    """
    nav_items = rng.sample(
        ["Home", "About", "Products", "Services", "Blog", "Contact", "FAQ", "Support"],
        k=rng.randint(4, 6),
    )

    if style == HtmlStyle.TRADITIONAL:
        links = "\n        ".join(
            f'<li><a href="/{item.lower()}">{item}</a></li>' for item in nav_items
        )
        return f'''<nav class="main-navigation">
    <ul class="nav-list">
        {links}
    </ul>
</nav>'''

    elif style == HtmlStyle.BOOTSTRAP:
        links = "\n            ".join(
            f'<li class="nav-item"><a class="nav-link" href="/{item.lower()}">{item}</a></li>'
            for item in nav_items
        )
        return f'''<nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container-fluid">
        <a class="navbar-brand" href="#">Brand</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            {links}
            </ul>
        </div>
    </div>
</nav>'''

    elif style == HtmlStyle.TAILWIND:
        links = "\n                ".join(
            f'<a href="/{item.lower()}" class="text-gray-700 hover:text-blue-600 px-3 py-2">{item}</a>'
            for item in nav_items
        )
        return f'''<nav class="bg-white shadow-sm">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex justify-between h-16">
            <div class="flex items-center">
                <span class="text-xl font-bold text-gray-900">Brand</span>
            </div>
            <div class="hidden md:flex items-center space-x-4">
                {links}
            </div>
        </div>
    </div>
</nav>'''

    elif style == HtmlStyle.REACT_SPA:
        links = "\n            ".join(
            f'<a href="/{item.lower()}" class="NavLink_item__x7k2j">{item}</a>'
            for item in nav_items
        )
        return f'''<nav class="Navigation_root__abc12" data-testid="main-nav">
    <div class="Navigation_container__def34">
        <div class="Navigation_brand__ghi56">Brand</div>
        <div class="Navigation_links__jkl78">
            {links}
        </div>
    </div>
</nav>'''

    elif style == HtmlStyle.ANGULAR:
        links = "\n            ".join(
            f'<a mat-button routerLink="/{item.lower()}">{item}</a>' for item in nav_items
        )
        return f'''<mat-toolbar color="primary" _ngcontent-ng-c123>
    <span>Brand</span>
    <span class="spacer"></span>
    <nav _ngcontent-ng-c124>
        {links}
    </nav>
</mat-toolbar>'''

    elif style == HtmlStyle.VUE:
        links = "\n            ".join(
            f'<router-link to="/{item.lower()}" class="nav-link" data-v-abc1234>{item}</router-link>'
            for item in nav_items
        )
        return f'''<nav class="v-navigation-drawer" data-v-abc1234>
    <div class="v-list" data-v-abc1234>
        {links}
    </div>
</nav>'''

    return ""


def generate_footer(rng: random.Random, style: HtmlStyle) -> str:
    """Generate style-appropriate footer markup.

    Args:
        rng: Random instance.
        style: The HTML style.

    Returns:
        HTML string for footer.
    """
    year = rng.randint(2020, 2025)
    company = rng.choice(["Acme Corp", "Example Inc", "Demo LLC", "Sample Co"])

    if style == HtmlStyle.TRADITIONAL:
        return f'''<footer class="site-footer">
    <div class="footer-content">
        <p>&copy; {year} {company}. All rights reserved.</p>
        <nav class="footer-nav">
            <a href="/privacy">Privacy Policy</a>
            <a href="/terms">Terms of Service</a>
        </nav>
    </div>
</footer>'''

    elif style == HtmlStyle.BOOTSTRAP:
        return f'''<footer class="bg-light py-4 mt-auto">
    <div class="container">
        <div class="row">
            <div class="col-md-6">
                <p class="text-muted mb-0">&copy; {year} {company}</p>
            </div>
            <div class="col-md-6 text-md-end">
                <a href="/privacy" class="text-muted me-3">Privacy</a>
                <a href="/terms" class="text-muted">Terms</a>
            </div>
        </div>
    </div>
</footer>'''

    elif style == HtmlStyle.TAILWIND:
        return f'''<footer class="bg-gray-100 border-t border-gray-200">
    <div class="max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
        <div class="flex flex-col md:flex-row justify-between items-center">
            <p class="text-gray-500 text-sm">&copy; {year} {company}</p>
            <div class="flex space-x-6 mt-4 md:mt-0">
                <a href="/privacy" class="text-gray-400 hover:text-gray-500 text-sm">Privacy</a>
                <a href="/terms" class="text-gray-400 hover:text-gray-500 text-sm">Terms</a>
            </div>
        </div>
    </div>
</footer>'''

    elif style in (HtmlStyle.REACT_SPA, HtmlStyle.ANGULAR, HtmlStyle.VUE):
        class_suffix = "".join(rng.choices(string.ascii_lowercase, k=5))
        return f'''<footer class="Footer_root__{class_suffix}">
    <div class="Footer_container__{class_suffix}">
        <p>&copy; {year} {company}</p>
    </div>
</footer>'''

    return f"<footer>Footer content</footer>"


def wrap_with_realistic_chrome(
    body_content: str,
    style: HtmlStyle,
    rng: random.Random,
    title: str = "Page Title",
    complexity: str = "medium",
    include_nav: bool = True,
    include_footer: bool = True,
    target_size: int | None = None,
) -> str:
    """Wrap body content with realistic HTML document structure.

    This function takes minimal body content (like a target element) and
    wraps it with realistic HTML chrome including head content, navigation,
    main wrapper, and footer based on the specified framework style.

    Args:
        body_content: The core content to wrap.
        style: The HTML framework style to use.
        rng: Random instance for deterministic generation.
        title: Page title.
        complexity: "low", "medium", "high", or "realistic".
            - low: ~2KB, minimal chrome
            - medium: ~3KB, standard chrome
            - high: ~4KB, full meta tags and analytics
            - realistic: 50KB+, matches real website sizes
        include_nav: Whether to include navigation.
        include_footer: Whether to include footer.
        target_size: Optional explicit target size for "realistic" mode.

    Returns:
        Complete HTML document string.
    """
    # For realistic complexity, treat as "high" for head content
    head_complexity = "high" if complexity == "realistic" else complexity
    head_content = generate_head_content(rng, style, title, head_complexity)

    # Build body parts
    body_parts = []

    if include_nav:
        body_parts.append(generate_navigation(rng, style))

    # Main content wrapper based on style
    if style == HtmlStyle.TRADITIONAL:
        body_parts.append(f'''<main class="main-content" role="main">
    <article class="page-article">
        {body_content}
    </article>
</main>''')

    elif style == HtmlStyle.BOOTSTRAP:
        body_parts.append(f'''<main class="container py-4">
    <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
            {body_content}
        </div>
    </div>
</main>''')

    elif style == HtmlStyle.TAILWIND:
        body_parts.append(f'''<main class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <div class="bg-white rounded-lg shadow-sm p-6">
        {body_content}
    </div>
</main>''')

    elif style == HtmlStyle.REACT_SPA:
        body_parts.append(f'''<div id="root" data-reactroot>
    <main class="App_main__xyz12">
        <div class="Content_wrapper__abc34">
            {body_content}
        </div>
    </main>
</div>''')

    elif style == HtmlStyle.ANGULAR:
        body_parts.append(f'''<app-root _nghost-ng-c100>
    <main class="mat-app-background" _ngcontent-ng-c101>
        <div class="content-wrapper" _ngcontent-ng-c102>
            {body_content}
        </div>
    </main>
</app-root>''')

    elif style == HtmlStyle.VUE:
        body_parts.append(f'''<div id="app" data-v-app>
    <main class="v-main" data-v-main>
        <div class="v-container" data-v-container>
            {body_content}
        </div>
    </main>
</div>''')

    else:
        body_parts.append(f"<main>{body_content}</main>")

    if include_footer:
        body_parts.append(generate_footer(rng, style))

    # For realistic complexity, add bulk content to reach target size
    if complexity == "realistic":
        # Default target: 50KB-100KB (matches real website median)
        actual_target = target_size or rng.randint(50000, 100000)

        # Replace simple nav with extended navigation (20-30 items with repeated classes)
        body_parts[0] = generate_repeated_navigation(rng, style, count=rng.randint(20, 30))

        # Add sidebar with mixed framework classes
        body_parts.insert(1, generate_sidebar_content(rng, style, items=25))

        # Add repeated elements section (like long dropdown menus)
        repeated_dropdown = generate_repeated_elements(
            rng, style, count=rng.randint(30, 50),
            element_type="li",
            wrapper_tag="ul",
            wrapper_class=f"mega-menu {random_branded_class(rng)}",
        )
        body_parts.insert(2, f'<div class="dropdown-container">{repeated_dropdown}</div>')

        # Add product grid or comments after main content
        if rng.random() < 0.5:
            body_parts.insert(-1, generate_product_grid(rng, style, count=12))
        else:
            body_parts.insert(-1, generate_comments_section(rng, style, count=15))

        # Generate additional bulk to reach target (using mixed framework elements)
        current_size = sum(len(p) for p in body_parts)
        if current_size < actual_target:
            bulk = generate_bulk_noise(rng, style, target_size=actual_target - current_size)
            body_parts.insert(-1, bulk)

        # Apply deep nesting with mixed framework classes to main content area
        for i, part in enumerate(body_parts):
            if "<main" in part or "<article" in part:
                body_parts[i] = generate_deep_nested_wrapper(
                    part, rng, style, depth=rng.randint(8, 15)
                )
                break

    body_html = "\n".join(body_parts)

    # Assemble full document
    return f'''<!DOCTYPE html>
<html lang="en">
<head>
    {head_content}
</head>
<body>
{body_html}
</body>
</html>'''


# =============================================================================
# Bulk Content Generators (for realistic HTML sizes)
# =============================================================================


def generate_sidebar_content(rng: random.Random, style: HtmlStyle, items: int = 20) -> str:
    """Generate sidebar content with links, widgets, and noise.

    Real websites have sidebars with 20-50 links, widgets, ads, etc.
    This adds realistic bulk to HTML documents.

    Args:
        rng: Random instance.
        style: The HTML style.
        items: Number of sidebar items to generate.

    Returns:
        HTML string for sidebar content.
    """
    # Recent posts/articles section
    recent_titles = [random_paragraph(rng, sentences=1).split('.')[0] for _ in range(items // 2)]
    recent_items = "\n".join(
        f'<li class="{random_class_for_style(rng, style, 2)}"><a href="/post/{i}">{title}</a></li>'
        for i, title in enumerate(recent_titles)
    )

    # Categories section
    categories = ["Technology", "Business", "Health", "Science", "Entertainment",
                  "Sports", "Travel", "Food", "Fashion", "Finance"]
    cat_items = "\n".join(
        f'<li class="{random_class_for_style(rng, style, 2)}"><a href="/category/{cat.lower()}">{cat}</a> <span>({rng.randint(5, 50)})</span></li>'
        for cat in rng.sample(categories, min(len(categories), items // 3))
    )

    # Tags cloud
    tags = ["python", "javascript", "react", "vue", "angular", "css", "html",
            "nodejs", "django", "flask", "aws", "docker", "kubernetes", "ml", "ai"]
    tag_items = " ".join(
        f'<a href="/tag/{tag}" class="{random_class_for_style(rng, style, 3)}">{tag}</a>'
        for tag in rng.sample(tags, min(len(tags), items // 2))
    )

    # Archive section
    months = ["January", "February", "March", "April", "May", "June",
              "July", "August", "September", "October", "November", "December"]
    archive_items = "\n".join(
        f'<li><a href="/archive/2024/{i+1:02d}">{month} 2024</a></li>'
        for i, month in enumerate(months[:items // 3])
    )

    if style == HtmlStyle.BOOTSTRAP:
        return f'''<aside class="col-lg-4">
    <div class="card mb-4">
        <div class="card-header">Recent Posts</div>
        <ul class="list-group list-group-flush">
            {recent_items}
        </ul>
    </div>
    <div class="card mb-4">
        <div class="card-header">Categories</div>
        <ul class="list-group list-group-flush">
            {cat_items}
        </ul>
    </div>
    <div class="card mb-4">
        <div class="card-header">Tags</div>
        <div class="card-body">
            {tag_items}
        </div>
    </div>
    <div class="card mb-4">
        <div class="card-header">Archive</div>
        <ul class="list-group list-group-flush">
            {archive_items}
        </ul>
    </div>
</aside>'''

    elif style == HtmlStyle.TAILWIND:
        return f'''<aside class="w-full lg:w-1/4 px-4">
    <div class="bg-white rounded-lg shadow-sm p-4 mb-4">
        <h3 class="text-lg font-semibold mb-3">Recent Posts</h3>
        <ul class="space-y-2">
            {recent_items}
        </ul>
    </div>
    <div class="bg-white rounded-lg shadow-sm p-4 mb-4">
        <h3 class="text-lg font-semibold mb-3">Categories</h3>
        <ul class="space-y-2">
            {cat_items}
        </ul>
    </div>
    <div class="bg-white rounded-lg shadow-sm p-4 mb-4">
        <h3 class="text-lg font-semibold mb-3">Tags</h3>
        <div class="flex flex-wrap gap-2">
            {tag_items}
        </div>
    </div>
</aside>'''

    else:
        return f'''<aside class="sidebar">
    <section class="widget">
        <h3>Recent Posts</h3>
        <ul>{recent_items}</ul>
    </section>
    <section class="widget">
        <h3>Categories</h3>
        <ul>{cat_items}</ul>
    </section>
    <section class="widget">
        <h3>Tags</h3>
        <div class="tag-cloud">{tag_items}</div>
    </section>
    <section class="widget">
        <h3>Archive</h3>
        <ul>{archive_items}</ul>
    </section>
</aside>'''


def generate_product_grid(rng: random.Random, style: HtmlStyle, count: int = 12) -> str:
    """Generate e-commerce style product grid.

    Real e-commerce sites have grids of 12-48 products with images,
    titles, prices, ratings, etc. This adds significant bulk.

    Args:
        rng: Random instance.
        style: The HTML style.
        count: Number of products.

    Returns:
        HTML string for product grid.
    """
    products = []
    for i in range(count):
        name = random_product_name(rng)
        price = random_price(rng)
        rating = round(rng.uniform(3.0, 5.0), 1)
        reviews = rng.randint(10, 500)
        desc = random_paragraph(rng, sentences=2)

        if style == HtmlStyle.BOOTSTRAP:
            product = f'''<div class="col-md-4 col-sm-6 mb-4">
    <div class="card h-100">
        <img src="/images/product-{i}.jpg" class="card-img-top" alt="{name}">
        <div class="card-body">
            <h5 class="card-title">{name}</h5>
            <p class="card-text text-muted">{desc}</p>
            <div class="d-flex justify-content-between align-items-center">
                <span class="h5 mb-0">{price}</span>
                <span class="badge bg-warning text-dark">{rating} ({reviews})</span>
            </div>
        </div>
        <div class="card-footer">
            <button class="btn btn-primary w-100">Add to Cart</button>
        </div>
    </div>
</div>'''

        elif style == HtmlStyle.TAILWIND:
            product = f'''<div class="bg-white rounded-lg shadow-sm overflow-hidden">
    <img src="/images/product-{i}.jpg" class="w-full h-48 object-cover" alt="{name}">
    <div class="p-4">
        <h3 class="text-lg font-semibold text-gray-900">{name}</h3>
        <p class="text-sm text-gray-500 mt-1">{desc}</p>
        <div class="flex justify-between items-center mt-4">
            <span class="text-xl font-bold text-gray-900">{price}</span>
            <span class="text-sm text-yellow-600">{rating} ({reviews} reviews)</span>
        </div>
        <button class="mt-4 w-full bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700">
            Add to Cart
        </button>
    </div>
</div>'''

        else:
            product = f'''<div class="product-card">
    <img src="/images/product-{i}.jpg" alt="{name}">
    <div class="product-info">
        <h3 class="product-title">{name}</h3>
        <p class="product-desc">{desc}</p>
        <span class="product-price">{price}</span>
        <span class="product-rating">{rating} ({reviews})</span>
        <button class="add-to-cart">Add to Cart</button>
    </div>
</div>'''

        products.append(product)

    grid_class = {
        HtmlStyle.BOOTSTRAP: "row",
        HtmlStyle.TAILWIND: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6",
    }.get(style, "product-grid")

    return f'<div class="{grid_class}">\n{"".join(products)}\n</div>'


def generate_comments_section(rng: random.Random, style: HtmlStyle, count: int = 10) -> str:
    """Generate comments section with nested replies.

    Real websites have comment sections with 5-50 comments,
    nested replies, avatars, timestamps, etc.

    Args:
        rng: Random instance.
        style: The HTML style.
        count: Number of comments.

    Returns:
        HTML string for comments section.
    """
    comments = []
    for i in range(count):
        author = random_person_name(rng)
        date = random_date(rng)
        content = random_paragraph(rng, sentences=rng.randint(2, 5))
        likes = rng.randint(0, 50)

        # Sometimes add nested replies
        replies_html = ""
        if rng.random() < 0.3:
            reply_author = random_person_name(rng)
            reply_content = random_paragraph(rng, sentences=rng.randint(1, 3))
            if style == HtmlStyle.BOOTSTRAP:
                replies_html = f'''<div class="ms-4 mt-3 p-3 bg-light rounded">
    <div class="d-flex">
        <img src="/avatars/default.jpg" class="rounded-circle me-2" width="32" height="32">
        <div>
            <strong>{reply_author}</strong> <small class="text-muted">in reply</small>
            <p class="mb-0">{reply_content}</p>
        </div>
    </div>
</div>'''
            else:
                replies_html = f'''<div class="comment-reply">
    <img src="/avatars/default.jpg" class="avatar-small">
    <div class="reply-content">
        <strong>{reply_author}</strong>
        <p>{reply_content}</p>
    </div>
</div>'''

        if style == HtmlStyle.BOOTSTRAP:
            comment = f'''<div class="card mb-3">
    <div class="card-body">
        <div class="d-flex">
            <img src="/avatars/user-{i}.jpg" class="rounded-circle me-3" width="48" height="48">
            <div class="flex-grow-1">
                <div class="d-flex justify-content-between">
                    <strong>{author}</strong>
                    <small class="text-muted">{date}</small>
                </div>
                <p class="mt-2">{content}</p>
                <div class="d-flex gap-3">
                    <a href="#" class="text-decoration-none"><i class="bi bi-hand-thumbs-up"></i> {likes}</a>
                    <a href="#" class="text-decoration-none">Reply</a>
                </div>
                {replies_html}
            </div>
        </div>
    </div>
</div>'''

        elif style == HtmlStyle.TAILWIND:
            comment = f'''<div class="bg-white rounded-lg shadow-sm p-4 mb-4">
    <div class="flex">
        <img src="/avatars/user-{i}.jpg" class="w-12 h-12 rounded-full mr-4">
        <div class="flex-1">
            <div class="flex justify-between items-center">
                <span class="font-semibold">{author}</span>
                <span class="text-sm text-gray-500">{date}</span>
            </div>
            <p class="mt-2 text-gray-700">{content}</p>
            <div class="flex gap-4 mt-3 text-sm">
                <button class="text-gray-500 hover:text-blue-600">Like ({likes})</button>
                <button class="text-gray-500 hover:text-blue-600">Reply</button>
            </div>
            {replies_html}
        </div>
    </div>
</div>'''

        else:
            comment = f'''<div class="comment">
    <img src="/avatars/user-{i}.jpg" class="avatar">
    <div class="comment-body">
        <div class="comment-header">
            <span class="author">{author}</span>
            <span class="date">{date}</span>
        </div>
        <p class="comment-text">{content}</p>
        <div class="comment-actions">
            <a href="#">Like ({likes})</a>
            <a href="#">Reply</a>
        </div>
        {replies_html}
    </div>
</div>'''

        comments.append(comment)

    return f'''<section class="comments-section">
    <h3>Comments ({count})</h3>
    {"".join(comments)}
</section>'''


def generate_deep_nested_wrapper(
    content: str,
    rng: random.Random,
    style: HtmlStyle,
    depth: int = 10,
) -> str:
    """Wrap content in deeply nested div structure.

    Real websites have average nesting depth of 25 levels.
    This adds realistic structural complexity.

    Args:
        content: Content to wrap.
        rng: Random instance.
        style: The HTML style.
        depth: How many levels to nest.

    Returns:
        Deeply nested HTML string.
    """
    result = content
    for i in range(depth):
        # Use mixed framework classes for more realistic nesting
        class_attr = generate_mixed_framework_classes(rng, style, count=rng.randint(1, 3))
        data_attrs = format_attributes(random_data_attributes(rng, style))
        result = f'<div class="{class_attr}"{data_attrs}>\n{result}\n</div>'
    return result


def generate_bulk_noise(rng: random.Random, style: HtmlStyle, target_size: int = 50000) -> str:
    """Generate bulk noise content to reach target HTML size.

    This combines various content types to build up to a target size,
    making the HTML more realistic. Uses mixed framework patterns and
    repeated elements based on Mind2Web analysis.

    Args:
        rng: Random instance.
        style: The HTML style.
        target_size: Target HTML size in characters.

    Returns:
        HTML string of bulk content.
    """
    parts = []
    current_size = 0

    generators = [
        # Standard content generators
        lambda: generate_product_grid(rng, style, count=rng.randint(6, 12)),
        lambda: generate_comments_section(rng, style, count=rng.randint(5, 15)),
        lambda: generate_sidebar_content(rng, style, items=rng.randint(15, 30)),

        # Mixed framework content blocks
        lambda: "".join(
            generate_mixed_framework_element(rng, style, random_paragraph(rng, rng.randint(2, 5)))
            for _ in range(rng.randint(5, 10))
        ),

        # Repeated elements with same class (like real dropdown menus)
        lambda: generate_repeated_elements(
            rng, style, count=rng.randint(20, 40),
            element_type="li", wrapper_tag="ul",
            wrapper_class=random_branded_class(rng),
        ),

        # Repeated navigation-style sections
        lambda: generate_repeated_navigation(rng, style, count=rng.randint(15, 25)),

        # Branded content sections
        lambda: f'''<section class="{random_branded_class(rng)} {random_state_class(rng)}">
    <h2 class="{random_branded_class(rng)}">{random_paragraph(rng, 1).split('.')[0]}</h2>
    {generate_repeated_elements(rng, style, count=rng.randint(10, 20), element_type="div")}
</section>''',
    ]

    while current_size < target_size:
        generator = rng.choice(generators)
        chunk = generator()
        parts.append(chunk)
        current_size += len(chunk)

    return "\n".join(parts)


# =============================================================================
# International Content Generators
# =============================================================================


def random_i18n_content(
    rng: random.Random,
    language: str | None = None,
) -> tuple[str, str]:
    """Generate content in a random or specified non-English language.

    Args:
        rng: Random instance.
        language: Language code (zh, ar, ja, ko, ru, de, etc.). If None, randomly selected.

    Returns:
        Tuple of (content_text, language_code).
    """
    from bs4_env.data.i18n_content import get_random_phrase

    return get_random_phrase(rng, language)


def random_i18n_word(
    rng: random.Random,
    language: str | None = None,
) -> tuple[str, str]:
    """Generate a single word in a random or specified language.

    Args:
        rng: Random instance.
        language: Language code. If None, randomly selected.

    Returns:
        Tuple of (word, language_code).
    """
    from bs4_env.data.i18n_content import get_random_word

    return get_random_word(rng, language)


def random_mixed_language_content(
    rng: random.Random,
    base_sentences: int = 3,
    foreign_ratio: float = 0.2,
) -> str:
    """Generate content mixing English with another language.

    Creates realistic mixed-language content like on international e-commerce
    sites that have partially translated pages.

    Example output: "Welcome to our store.  Browse our products below."

    Args:
        rng: Random instance.
        base_sentences: Number of English sentences to generate.
        foreign_ratio: Probability of inserting foreign phrase after each sentence.

    Returns:
        Mixed language content string.
    """
    from bs4_env.data.i18n_content import get_random_phrase, get_random_language

    # Generate base English content
    english_sentences = [generate_sentence(rng) for _ in range(base_sentences)]

    # Pick a single foreign language for consistency
    foreign_lang = get_random_language(rng)
    result = []

    for sentence in english_sentences:
        result.append(sentence)
        # Sometimes insert foreign phrase
        if rng.random() < foreign_ratio:
            foreign_phrase, _ = get_random_phrase(rng, foreign_lang)
            result.append(foreign_phrase)

    return " ".join(result)


def add_emoji_noise(
    text: str,
    rng: random.Random,
    density: float = 0.1,
    category: str | None = None,
) -> str:
    """Add realistic emoji to text content.

    Emojis are common in modern web content, especially social media,
    e-commerce reviews, and marketing pages.

    Args:
        text: Base text to add emoji to.
        rng: Random instance.
        density: Probability of adding emoji after each sentence (0-1).
        category: Emoji category (positive, commerce, navigation, status, social).
                  If None, randomly selected per emoji.

    Returns:
        Text with emoji inserted.
    """
    from bs4_env.data.i18n_content import get_random_emoji

    sentences = text.split(". ")
    result = []

    for sentence in sentences:
        result.append(sentence)
        if rng.random() < density:
            emoji = get_random_emoji(rng, category)
            # Add emoji at end of sentence
            if result[-1] and not result[-1].endswith((".", "!", "?")):
                result[-1] = result[-1] + " " + emoji
            else:
                result.append(emoji)

    return ". ".join(result)


def add_special_unicode(
    text: str,
    rng: random.Random,
    density: float = 0.05,
    category: str | None = None,
) -> str:
    """Add special Unicode characters that can cause parsing issues.

    Tests edge cases like zero-width characters, diacritics, and special
    symbols that are common in real web content.

    Args:
        text: Base text.
        rng: Random instance.
        density: Probability of inserting special char at each position.
        category: Character category. If None, randomly selected.

    Returns:
        Text with special characters inserted.
    """
    from bs4_env.data.i18n_content import get_random_special_char

    result = []
    for char in text:
        result.append(char)
        if rng.random() < density:
            special = get_random_special_char(rng, category)
            result.append(special)

    return "".join(result)


def generate_i18n_paragraph(
    rng: random.Random,
    language: str | None = None,
    sentences: int = 3,
) -> tuple[str, str]:
    """Generate a paragraph in a specific language.

    Args:
        rng: Random instance.
        language: Language code. If None, randomly selected.
        sentences: Number of phrases to combine.

    Returns:
        Tuple of (paragraph_text, language_code).
    """
    from bs4_env.data.i18n_content import get_random_phrase, get_random_language

    if language is None:
        language = get_random_language(rng)

    phrases = []
    for _ in range(sentences):
        phrase, _ = get_random_phrase(rng, language)
        phrases.append(phrase)

    # Use appropriate punctuation
    if language in {"zh", "ja"}:
        # Chinese/Japanese use different punctuation
        text = "".join(phrases) + ""
    elif language == "ar":
        # Arabic punctuation
        text = " ".join(phrases) + "."
    else:
        text = ". ".join(phrases) + "."

    return text, language


def get_rtl_wrapper(content: str, language: str) -> str:
    """Wrap RTL content with proper HTML direction attribute.

    Args:
        content: Text content.
        language: Language code.

    Returns:
        HTML span with dir attribute if RTL, otherwise just content.
    """
    from bs4_env.data.i18n_content import is_rtl_language

    if is_rtl_language(language):
        return f'<span dir="rtl" lang="{language}">{content}</span>'
    return f'<span lang="{language}">{content}</span>'


def generate_variable_i18n_content(
    rng: random.Random,
    min_sentences: int = 1,
    max_sentences: int = 5,
    language: str | None = None,
) -> tuple[str, str]:
    """Generate variable-length international content.

    Combines variable-length content with i18n support for maximum variation.

    Args:
        rng: Random instance.
        min_sentences: Minimum phrases.
        max_sentences: Maximum phrases.
        language: Language code. If None, randomly selected.

    Returns:
        Tuple of (content, language_code).
    """
    sentence_count = rng.randint(min_sentences, max_sentences)
    return generate_i18n_paragraph(rng, language, sentence_count)
